#!/usr/bin/python3
# Copyright (C) 2015-2021 Harold Grovesteen
#
# This file is part of SATK.
#
#     SATK is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
#
#     SATK is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
#
#     You should have received a copy of the GNU General Public License
#     along with SATK.  If not, see <http://www.gnu.org/licenses/>.

# This module defines a class for each supported directive and machine instruction

# Other Notices:
# z/Architecture is a registered trademark of International Business Machines
# Corporation.

this_module="asmstmts.py"

# Python imports:
import re             # Access regular expression module
# SATK imports:
import fp             # Access the FPError exception
# ASMA imports:
import assembler
import asmbase
import asmtokens
import asmline
#import asmfsmcs
import insnbldr
import literal
import lnkbase
import macopnd
import macsyms
#import asmfsmbp
import asmmacs
import asmdcds
import model


#
#  +------------------------------------+
#  |                                    |
#  |   Standardized Attribute Support   |
#  |                                    |
#  +------------------------------------+
#

# These global symbols allow standardized support for attributes with different
# statement types:

A_OC="ILMS"
A_MAC="DKNOT%s" % A_OC


#
#  +-------------------------------------+
#  |                                     |
#  |   Binary Structure Template Class   |
#  |                                     |
#  +-------------------------------------+
#

# The Structure class creates a template for the generation of any binary structure.
# For assembler directives, it is analogous to the insnbldr.Instruction class used
# for generating an instruction.  The template is instantiated once and then reused
# each time the corresponding structure is generated by a directive.
#
# Template Field objects supplied with a value will override a value supplied to the
# build() method when being built.  Note that a value must be supplied for the field
# when the build() method is called.  The value is simply ignored.  It is recommended
# that None be used for such fields when the build() method is called.
#
# Instance arguments:
#    fields    A list of insnbldr.Field objects defining the structure's template
class Structure(object):
    def __init__(self,name,builder,fields=[]):
        self.name=name                  # Template name
        self.builder=builder            # The single insnbldr.Builder object.
        self.fields=fields              # List of insnbldr.Field objects
        self.num_flds=len(self.fields)  # Number of Field objects in list

    # Generate the structure as a bytes sequence.
    # Method arguments:
    #    stmt      The Stmt object of the statement associated with the directive
    #    values    A list of integers (may include None) to be placed in each field
    #              of the template.
    def build(self,stmt,values=[],trace=False):
        num_flds=self.num_flds
        assert len(values)==num_flds,\
            "%s number of supplied values does not match the number of fields "\
                "(%s): %s" % (assembler.eloc(self,"build",module=this_module),\
                    num_flds,len(values))

        fields=self.fields
        builder=self.builder
        binlen=len(stmt.content)
        lineno=stmt.lineno

        # This is the structure being built.  Python integers may be of any size.
        # The algorithm used below uses this fact letting a Python integer be the
        # structure while under construction.  The Python 3.3 enhancements allow
        # this integer to be turned in a bytes sequence, subsequently used as the
        # binary content of the structure.
        bin=0      # This is the structure being built
        for ndx in range(num_flds):
            fld=fields[ndx]
            was_none=False
            if fld.value is None:
                was_none=True         # This ensures values don't get reused
                fld.value=values[ndx]

            if __debug__:
                if trace:
                    print("%s field %s: %s" \
                        % (assembler.eloc(self,"build",module=this_module),ndx,fld))

            # Insert each field individually into the structure
            bin=fld.insert(binlen,bin,builder,lineno,signed=fld.signed)
            # This ensures values don't get reused on the next use of the template
            if was_none:
                fld.value=None

        # Return the structure as bytes list.
        return bin.to_bytes(binlen,byteorder="big",signed=False)


#
#  +--------------------------+
#  |                          |
#  |   Statement Base Class   |
#  |                          |
#  +--------------------------+
#

# Base class for all statement subclasses.  The operation type defined for the
# statement's operation drives how this object is constructed.  The operation
# type must be coordinated with the subclass for proper creation and handling.
# The type is derived very early in a statement's processing when the physical line
# is read, even before the logical line is constructed.
class ASMStmt(object):
    # Statement processing controls are class attributes that aid in processing
    # the statement(s) supported by the class.  These attributes are referenced
    # by various modules that participate in the process.  They have no meaning
    # for the base class which is itself never directly instantiated.  The attributes
    # have been coded here purely for documentation purposes.
    #
    # Attributes alt, attrs, and spaces are only used when sep=True.

    # Statement type.  Used by asmoper.getOper() method to recognize a macro
    # directive during a macro definition.  The following values are used:
    #   MD    Macro definitional statement: MEND, MEXIT
    #   ML    reserved
    #   MO    A macro operation: ACTR, AGO, AIF, ANOP, GBLx, LCLx
    #   MS    A macro set operation: SETx
    #
    # This type influences statement printing in AsmStmt.pr_set() method.
    #   M     Invoked macro definition
    #
    # These types are purely for documentation and consistency:
    #   I     Machine instruction
    #   MG    A macro model statement
    #   MP    A macro prototype statement
    #   SPP   Uses a special pre-processor method.  Most assembler directives.
    #   SSP   DC assembler directive.
    #   TPL   Template using assembler directives:  CCW[x], CNOP, DROP, ENTRY, EQU,
    #             ORG, PSW[x], USING.
    typ=None       # Statement type identifie

    # Label Field Content.  This field defines what may appear in the statement's
    # label field.  It is a string, each character representing a type of allowed
    # content.  The values are examined by asmline.LField.validate() method
    #
    #  L   a normal label (may not contain a symbolic macro variable)
    #  M   a macro model statement label (may contain a symbolic macro variable)
    #  S   a symbolic macro variable.
    #  Q   a sequence symbol
    lfld="MLSQ"    # Valid label field content

    # Operation Field Content.  Performs the same role for the operation field as
    # does the previous attribute for the label field.  The same values are
    # used with the same asmline.LField.validate() method.  However, the operation
    # field will never allow a sequence symbol.  See the lfld description for
    # details.
    ofld="LS"      # Valid operation field content

    # Whether the alternate statement format is allowed for the statement.  It is
    # used by the operand separation finite state machine asmline.cfsm and
    # used by the ACT_Comma() and ACT_Found_Comment() methods.  The value is passed
    # to the machine via the call to asmline.LineMgr.findOperands() method in
    # the AsmStmt.parse_line() method.
    alt=False      # Whether the alternate statement format is allowed

    # Defines the name of the parser to be used for parsing operands separated
    # when attribut sep=True.  This parser is used when AsmStmt.parse_sep() method
    # is called.
    parser="mopnd" # Operand parser used by statement

    # Whether operands within the logical line should be separated or not.  Some
    # statements expect the operands to be separated (and processed individually)
    # and some expect to process the entire logical line doing its one operand
    # separation.  Like the alt attribute, the sep attribute value is passed to the
    # asmline.LineMgr.findOperands() in the AsmStmt.parse_line() method.
    # It controls whether the operand separation finite state machine asmline.csfm
    # is used or not.  When not used, the operand field from each physical line
    # is concatenated in one long string for processing by the statement.
    sep=True       # Whether operands are to be separated from the logline

    # Whether spaces may occur within the operand field, for example some macro
    # directives or not, for example machine instructions.  Like the alt and sep
    # attributes, the spaces attribute's value is passed to
    # asmline.LineMgr.findOperands() in the AsmStmt.parse_line() method.  The
    # finite state machine asmline.cfsm's action method ACT_Comment is sensitive
    # to its value.
    spaces=False   # Whether operand field may have spaces outside of quoted strings

    # For some statements, only a comma indicates the end of an operand when
    # encountered outside of a parenthesized portion of the operand or quotes.
    # This is spaces on steroids.
    comma=False    # Whether only a comma indicates the end of an operand

    # Specifies which label or symbol attributes are allowed in operands.  The
    # asmline.cfsm finite state machine must know this information so that it does
    # not recognize a quoted string when a quoted string could be present.
    # Like alt, sep, and spaces, the attrs attribute is passed to the finite state
    # machine, via the call to asmline.LineMgr.findOperands() in the
    # AsmStmt.parse_line() method.  The ACT_Attr finite state machine action method
    # is sensitive to the value is a string.
    #    None    Disables symbol attribute recognition.
    #    "xx"    The specified attributes are recognized.
    #    ""      Recognizes all valid attributes.
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        assert isinstance(logline,asmline.LogLine),\
            "%s 'logline' argument not a asmline.LogLine object: %s" \
                 % (assembler.eloc(self,"__init__",module=this_module),logline)
        # The logical line _must_ contain valid operation management objects
        # If not something went wrong in the asmline module
        assert isinstance(logline.optn,asmbase.ASMOper),\
            "'logline.optn' attribute must be an instance of asmbase.ASMOper: %s" \
                % logline.optn

        self.lineno=lineno         # Global statement number
        self.logline=logline       # asmline.LogLine (or None)
        self.ignore=logline.ignore # Ignore if True (empty or comment statements)
        self.genlvl=logline.genlvl # Logical line generation level
        self.source=logline.source # Source of the logical line
        self.label_fld=None        # Label Field (LField object)
        self.oper_fld=None         # Operation Field (LField object)

        # Manages symbolic replacement
        self.amp=False             # Whether ampersands are present.
        self.amp_list=[]           # Objects that may need symbolic replacement
        self.norep=False           # Whether symbolic replacement should be attempted

        # Extract operation management attributes for the statement
        self.optn=logline.optn     # ASMOper object
        self.instu=self.optn.oper  # The operation name in upper case
        self.asmdir=False          # Subclass must set this if an assembler directive
        self.macdir=False          # Subclass must set this if a macro directive

        # Statement processing controls
        cls=self.__class__         # Processing controls are class attributes
        self.spaces=cls.spaces     # Set whether spaces can be in operands
        self.comma=cls.comma       # Set whether only comma forces an operand
        self.sep=cls.sep           # Whether operands parsed into LOperand objects
        self.alt=cls.alt           # Set whether alternate statement format supported
        self.T=cls.typ             # Operation type - some values used for T'attribute

        # General state flags.  Once either is set True future processing is inhibited
        # Master processing switch.  All passes check ignore to determine if the
        # statement should be processed.
        self.ignore=False          # Ignore if True
        self.trace=False           # Causes statement tracing in all passes
        self.error=False           # Logical line error's propagate upward
        # When setting self.error to True, self.ignore should also be set to True

     # Logical Operand Field or individual LOperand objects - see parse_operands()

        # Statement operands will be associated with one of these attributes
        # depending upon how the operand field in the physical lines are
        # processed by the statement.  Which field is used is determined by self.sep
        # derived from the ASMOperType.sep attribute of the operation:

        # sep=False: Entire Operand Field from all continued lines (LOperands
        #            object).  The statement parser must be prepared to separate
        #            operands itself.
        self.opnd_fld=None         # Entire Operation Field (LOperands object)

        # sep=True:  List of LOperand objects.  The statment parser must be prepared
        #            to parse the operands separately.
        self.operands=[]

     # Location Counter for this statement
        self.location=None

     # Pass 0
        self.P0_operands=[]        # Parser output list
        # List of assembler.Operand subclass instances.  Updated with actual values
        # during Pass 2.  See MachineStmt.Pass0() and Template.create_bin_list()
        # methods.
        self.bin_oprs=[]

     # Pass 1
        # Binary object of all zeros is created in pass 1.  The actual binary
        # content is provided in pass 2.
        self.content=None          # Binary instance for image content creation
        self.p1_loc=None           # Statement location in Pass 1 (Section relative)

     # Pass 2
        # Upates self.content with actual binary data.
        self.p2_loc=None           # Statement location in Pass 2 (absolute)

     # Listing

        # Listing state flags:
        # True means this is a print directive - processing deferred to listing
        self.prdir=False           # Set by subclass if required
        self.plist=None            # Information passed to listing manager
        # These are established by pr_set() method.
        self.pon=True              # Assume "PRINT ON" directive
        self.pgen=True             # Assume "PRINT GEN" directive
        self.pdata=False           # Assume "PRINT NODATA" directive
        self.gened=False           # Whether statement was generated

        # Note: Assembler directives will set the values as [addr1,addr2].
        # Instructions will set laddr as the address is encountered.  The asmlist
        # module will need to figure out which address is "first" and which is "last"
        # for proper placement in the listing ADDR1 and ADDR2 columns for instructions.
        # During Pass 1 some directives may save some information in the laddr
        # attribute for use in Pass 2 where the final values are established for some
        # directives.
        self.laddr=[None,None]     # Addresses from operand evaluations

        # List of errors printed in the listing for this statement.  Usually one.
        self.aes=[]                # List of AssemblerError objects.

    # Add an AssemblerError to this statement.  Macro errors may be added even after
    # the macro statement has been successfully invoked.
    def ae_error(self,ae):
        if ae.info and not ae.nostmt:
            # Treat the AssemblerError object as an optional warning message
            self.aes.append(ae)  # Add the AssemblerError object to my error list
            return

        # Treat AssemblerError object as a error if not a warning
        if not ae.warning:
            self.error=True        # Indicate this statement is now in error
            self.ignore=True       # Make sure it is further ignored.
        self.aes.append(ae)    # Add the AssemblerError to my error list


    # Inspect the logical operands for the presence of literals.
    # Method Argument:
    #   allowed   A list of operand indices where a literal is allowed.  An empty
    #             list means a literal is not allowed for any operand,
    # Exception:
    #   AssemblerError if an operand is a literal but not allowed for the operand.
    def ck_for_literals(self,allowed=[]):
        for n,opnd in enumerate(self.operands):
            if opnd is None:
                raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                    msg="%s operation does not permit an empty operand %s" \
                        % (self.instu,n+1))
            if opnd.isLiteral and (not n in allowed):
                raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                    msg="%s operation does not permit a literal for operand %s" \
                        % (self.instu,n+1))

    # Pass 0 - Checks that a macro definition is being built and returns the infefn
    #          attribute
    # Returns:
    #   the indefn attribute of the macro operand, an asmmacs.Macro object
    # Excetion:
    #   AssemblerError if not within a macro definition
    def ck_in_macro_defn(self,macro,state,oper):
        assert isinstance(macro,asmmacs.MacroBuilder),\
            "%s 'macro' argument must a asmmacs.MacroBuilder object: %s" \
                % (eloc(self,"ck_in_macro_defn",module=this_module),macro)

        if macro.indefn is None or macro.state==0:
            raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                msg="%s statement is not valid outside of a macro definition" % oper)
        if macro.state!=state:
            if state==1:
                raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                    msg="%s statement not a valid macro prototype" % oper)
            elif state==2:
                raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                    msg="%s statement only valid in a macro body" % oper)
            else:
                raise ValueError("%s invalid expected state: %s" \
                    % (assembler.eloc(self,"ck_in_macro_defn",module=this_module),\
                        state))

        return macro.indefn

    # Pass 0 - Determine if the minimum number of operands are present
    # Method Argument:
    #   minimum   Minimum required
    # Exception:
    #   AssemblerError if fewer operands are present than required.
    def ck_min_operands(self,minimum=None):
        if minimum is None:
            return
        if len(self.P0_operands)<minimum:
            if minimum>1:
                s="s"
            else:
                s=""
            raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                msg="%s operation requires at least %s operand%s, encountered: %s" \
                    % (self.instu,minimum,s,len(self.P0_operands)))

    # Pass 0 - Checks that a statement is outside of a macro definition.
    # Exception:
    #   AssemblerError if statement occurs inside of a macro definition
    def ck_out_of_macro_defn(self,macro,oper):
        assert isinstance(macro,asmmacs.MacroBuilder),\
            "%s 'macro' argument must a asmmacs.MacroBuilder object: %s" \
                % (eloc(self,"ck_out_of_macro_defn",module=this_module),macro)
        if macro.state==0:
            return
        raise assembler.AssemblerError(line=self.lineno,source=self.source,\
            msg="%s statement may only appear outside of a macro definition" % oper)

    # Check that the supplied argument is a list and print each item in the list
    def debug_list(self,lst):
        cls_str=assembler.eloc(self,"debug_list",module=this_module)
        if not isinstance(lst,list):
            print("%s [%s] not list: %s" % (cls_str,self.lineno,lst))
            return
        for n,item in enumerate(lst):
            print("%s [%s] list item %s: %s" % (cls_str,self.lineno,n,item))

    # Supply debug information related to P0_operands
    def debug_P0(self,cls=None):
        cls_str=assembler.eloc(self,"debug_P0",module=this_module)
        for n,opnd in enumerate(self.P0_operands):
            if cls:
                if not isinstance(opnd,cls):
                    print("%s [%s] opnd %s: not class %s: %s" \
                        % (cls_str,self.lineno,n+1,cls.__name__,opnd))
                    continue
            print("%s [%s] opnd %s: %s" \
                % (cls_str,self.lineno,n,opnd.display(string=True)))

    # Supply debug information related to line parse found in operands
    def debug_sep(self):
        cls_str=assembler.eloc(self,"debug_sep",module=this_module)
        for n,opnd in enumerate(self.operands):
            if opnd is None:
                t="None"
            else:
                t="'%s'" % opnd.text
            print("%s [%s] opnd %s: %s" \
                % (cls_str,self.lineno,n,t))

    # Pass 2 - Machine Instruction and Template operand evaluation.
    #
    # self.PO_operands contains the list separated operands from the operand
    # field in the source statement.
    # The conversion of the source operand (asmline.LOperand objects) into
    # object binary content is controlled by the corresponding element
    # (asmbase.Operand object) in the self.bin_opers list
    #
    # This method updates the Operand object with a list of _evalutated_ expressions
    # used to create either the machine instruction or binary structure.  The
    # actual binary creation occurs in the insnbldr module.
    #
    # This method performs the expression evaluation and update of the Operand
    # objects in preparation for object construction
    def evaluate_operands(self,asm,debug=False,trace=False):
        num_src=len(self.P0_operands)    # Number of operands in source statement

        # Pass source statement expressions to each binary operand object and
        # evalues.
        #expr_list=[]
        for n,bin_opr in enumerate(self.bin_oprs):
            if __debug__:
                if trace:
                    print("%s [%s] source operand %s: %s" \
                        % (assembler.eloc(self,"evaluate_operands"),\
                            self.lineno,n,bin_opr))

            # Build expression list from source operands (asmbase.ASMOperand)
            # Fetch the operand from the source statement.  Treat missing operands
            # as omitted.
            if n>=num_src:
                opnd=None
            else:
                opnd=self.P0_operands[n]

            # Use omitted values for omitted operand
            if opnd is None:
                omitted=bin_opr.__class__.omitted
                if __debug__:
                    if trace:
                        print("%s [%s] setting operand %s to omitted: %s" \
                            % (assembler.eloc(self,"evaluate_operands"),\
                                self.lineno,n,omitted))
                #bin_opr.values=bin_opr.__class__.omitted
                bin_opr.values=omitted
                if not bin_opr.validate_expr(trace=trace):
                    raise ValueError("%s [%s] omitted operand %s did not validate: %s"\
                        % (assembler.eloc(self,"evaluate_operands",\
                            module=this_module),self.lineno,n+1,omitted))
                continue

            # Prepare an Literal for operand evaluation.
            if isinstance(opnd,assembler.Literal):
                assert opnd.state == 5,\
                    "%s literal operand %s %r state not 5: %s" \
                        % (assembler.eloc(self,"evaluate_operands",\
                            module=this_module),n+1,opnd,opnd.state)
                expr_list=[opnd,]

            else:
                # Update Operand object with a list of arithmetic expressions
                name=self.__class__.__name__

                # Transform primary lexical token expression into an arith expression
                desc="%s:%s-P" % (name,n)
                pexp=opnd._primary
                if __debug__:
                    if trace:
                        print("%s pexp: %s" \
                            % (assembler.eloc(self,"evaluate_operands",\
                                module=this_module),pexp))

                pexp.prepare(self,desc)
                expr_list=[pexp,]

                # Transform any secondary expressions into arith expression
                for sec,exp in enumerate(opnd._secondary):
                    if exp is None:
                        expr_list.append(None)
                    else:
                        desc="%s:%s-S%s" % (name,n,sec)
                        exp.prepare(self,desc)
                        expr_list.append( exp )

            # Pad list with None object until we have three
            while len(expr_list)<3:
                expr_list.append(None)
            # Update the Operand object with transformed ASMExpr objects
            bin_opr.exprs=expr_list

            try:
                #print("%s bin_opr: %s" \
                #    % (assembler.eloc(self,"evaluate_operands",module=this_module),\
                #        bin_opr))
                bin_opr.evaluate(asm,debug=debug,trace=trace)
            except lnkbase.AddrArithError as ae:
                raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                    msg="operand %s %s" % (n+1,ae.msg)) from None
            except assembler.LabelError as le:
                raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                    msg="operand %s undefined label: %s" % (n+1,le.label)) from None

            if not bin_opr.validate_expr(trace=trace):
                raise assembler.AssemblerError(line=self.lineno,\
                    msg="operand %s %s" % (n+1,bin_opr.value_error()))

    # Return the operand parser ID as specified in the ASMOperType object
    def get_Operand_Parser(self):
        return self.__class__.parser

    # Pass 1 - Create a label if present
    def label_create(self,asm,length=None,T="U",S=0,I=0):
        #print("%s T:%s S:%s I:%s" \
        #    % (assembler.eloc(self,"label_create",module=this_module),T,S,I))
        lbl=self.label_fld
        if lbl and lbl.typ == "L":
            asm._label_create(self,lbl.text,length=length,T=T,S=S,I=I)

    # Pass 0 - Validate a required label is present and return it
    # Returns:
    #   the optional label as a string or
    #   None   if omitted or is a sequence symbol or symbolic variable
    def label_optional(self):
        lbl=self.label_fld
        if lbl is None or lbl.typ!="L":
            return None
        return lbl.text

    # Pass 0 - Ensure prohibited label is not present
    # Returns: None
    # Exceptions:
    #    AssemblerError if label is present but is prohibited
    def label_prohibited(self):
        if self.label_fld is not None:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operation prohibits a label, found: %s" \
                    % (self.instu,self.label_fld.text))

    # Pass 0 - Validate a required label is present and return it
    # Returns:
    #   the label as a string
    # Exception:
    #   AssemblerError if label field is omitted or the label is a sequence symbol
    #                  or symbolic variable.
    #
    def label_required(self):
        lbl=self.label_fld
        if lbl is None:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operation requires a label, omitted" % self.instu)
        label=lbl.text
        if lbl.typ!="L":
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operation requires a label, found: %s" % (self.instu,label))
        return label

    # Pass 0 - Create a Literal pool and inject it into the input stream.
    #          Used by LTORG and END directives.
    #
    # Method Arguments:
    #   asm     the global assembler.Assembler object
    #   new     Specify True to cause a new pool to be initiated following the
    #           creation of this pool.
    #   debug   Specify True to cause debug message generation
    # Returns:
    #   a tuple: tuple[0]  The literal.LiteralPool object of the created pool or None
    #                      if the pool is empty
    #            typle[1]  The alignment required for the pool.
    def literal_pool_create(self,asm,new=False,debug=False):
        mgr=asm.LPM
        if mgr.isEmpty():
            if __debug__:
                if debug:
                    p=mgr.current()
                    print("%s [%s] ignoring empty literal pool %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.lineno,p.pool_id))

            # This pool is empty, no need to do anything here and we can leave it
            # in the pool manager for the next use.
            return (None,0)

        # Pool has literals so we now need to create them.
        pool=mgr.create(self.lineno,debug=debug)
        if __debug__:
            if debug:
                print("%s [%s] creating literal pool:\n%s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,pool.display(indent="    ",string=True)))

        align=pool._align
        literals=pool.pool_list
        if __debug__:
            if debug:
                print("%s pool %s literals: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        pool.pool_id,literals))

        for lit in literals:
            if __debug__:
                if debug:
                    print("%s creating pool %s literal: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            pool.pool_id,lit))

        # Inject the literal pool into the input stream.
        asm.IM.newPool(pool,genlvl=self.genlvl,debug=debug)
        # Start a new pool
        if new:
            mgr.pool_new()
            if __debug__:
                if debug:
                    assert mgr.isEmpty(),\
                        "%s [%s] new literal pool is not empty" \
                            % (assembler.eloc(self,"Pass0",module=this_module),\
                                self.lineno)

        return (pool,align)

    # Pass 1 - Create the binary content for a new statement and assign a label if
    #          present.  The minimum length of the label is one regardless of the
    #          length of the binary content.
    #
    # Method arguments:
    #   asm        The shared assembler.Assembler instance of the run
    #   alignment  Alignement of the binary content.
    #   length     Length of the binary content (can be zero)
    def new_content(self,asm,alignment=0,length=0,T="U",debug=False):
        # Create Binary instance for the new content
        bin=assembler.Binary(alignment,length)
        # Establish the content for this statement
        self.content=bin
        # Make sure a section exists to which the binary content is added
        asm._check_cur_sec(debug=debug)
        # Assign to it its '*' value
        asm.cur_sec.assign(bin)
        # Current location counter is start of binary with a section relative address

        # If a label is present, assign it this value and length
        self.label_create(asm,length=max(length,1),T=T)

    # Pass 0 - Parse from physical lines the logical operands in the operand
    #          field(s).  This is the default handling.  A subclass may override
    #          if physical lines require different handling.  The ASMStmt class
    #          attributes control this process.
    #
    #          The input manager is used to perform the separation of operands.
    #          The process is sensitive to paired left/right parenthesis nesting,
    #          quoted strings and attributes (which contain a single quote).
    #          This is where macro alternate statement formats, macro parameters
    #          and machine instruction operands are all recognized.
    #
    #          The master control or this process is the class attribute sep.
    #          If sep is None or False, no action is taken by the operand separation
    #          process.  Refer to asmline.LineMgr.findOperands() method and the
    #          corresponding asmline.cfsm character level recognizer for details.
    # Exception:
    #   AssemblerError if operand recognition fails.  Usually the result of
    #   mismatched pair of parenthesis or single quotes.
    #
    #   Note: This is where occasionally the presence of an attribute will generate
    #   an error and require some recoding to workaround the problem.
    def parse_line(self,asm,alt=None,sep=None,spaces=None,comma=None,debug=False):
        # Parse into LOperand objects, all of the operands in the logical line

        # Allow method call to overide the default object attributes for alt,
        # sep and spaces.  Overrides are used for macro model statement parsing
        if alt is None:
            palt=self.alt
        else:
            palt=alt
        if sep is None:
            psep=self.sep
        else:
            psep=psep
        if spaces is None:
            pspaces=self.spaces
        else:
            spaces=spaces
        if comma is None:
            pcomma=self.comma
        else:
            pcomma=comma

        logline=self.logline
        #if self.lineno==182:
        #    ddebug=True
        #else:
        #    ddebug=debug # or True
        ddebug=debug # or True
        if __debug__:
            if ddebug:
                cls_str=assembler.eloc(self,"parse_line",module=this_module)
                print("%s logline: %s" % (cls_str,logline))

        try:
            asm.IM.findOperands(logline,alt=palt,attrs=self.attrs,sep=psep,\
                spaces=pspaces,comma=pcomma,debug=ddebug)
        except asmline.LineError as le:
            # re-raise exception as an assembler error
            raise assembler.AssemblerError(source=le.source,line=self.lineno,\
                msg=le.msg) from None

        # Allow statement access to the operands found by the logical line
        self.opnd_fld=logline.opnd_fld
        if self.opnd_fld:
            self.amp=self.amp or self.opnd_fld.amp
            self.amp_list.append(self.opnd_fld)
        self.operands=logline.operands
        for opnd in self.operands:
            if opnd is None:
                continue
            self.amp=self.amp or opnd.amp
            self.amp_list.append(opnd)

        if __debug__:
            if ddebug:
                print("%s stmt.opnd_fld: %s operands: %s" \
                    % (cls_str,self.opnd_fld,self.operands))

    # Parses separated operands using the ASMOperType object's parser.  Result
    # placed in attribute PO_operands
    # Method Arguments:
    #   asm    The assembler.Assembler object
    #   debug  If True, displays the results of self.parse_line() method
    # Exceptions:
    #   AssemblerError
    def parse_sep(self,asm,debug=False):
        if __debug__:
            if debug:
                self.debug_sep()
        try:
            self.P0_operands=asm.PM.parse_sep(self,debug=debug)
        except assembler.AsmParserError as ape:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg=ape.msg)
        if __debug__:
            if debug:
                print("%s P0_operands: %s" \
                    % (assembler.eloc(self,"parse_sep",module=this_module),\
                        self.P0_operands))

    # Adjust print setting based upon the statement's generation level,
    # statement type and mcall setting
    def pr_set(self,on=True,data=True,gen=False,mcall=False):
        self.pon=on
        self.pdata=data
        self.pgen=gen
        self.gened=self.genlvl is not None  # Listing gets a "+"
        # Special handling for inner macro calls
        if self.T=="M" and self.gened and self.genlvl>=1:
            self.pon=self.pon and mcall

    # Pass 0 - Validae that the label field, when present, and operation field
    #          is always valid.  Pass upward to the ASMStmt subclass whether
    #          an ampersand appears in the field.  The presence of at least one
    #          ampersand will trigger in a model statement symbolic replacement.
    # Returns:
    #   Whether the statement is being traced as specified in the --oper command-line
    #   argument or in an ACTRACEON assembler directive.  The caller can ignore the
    #   returned value if uninterested in this state.
    # Exception:
    #   AssemblerError if either the operation or label field is invalid
    def pre_process(self,asm):
        trace=self.trace=asm._is_otrace(self.instu)   # Set operation based tracing

        if __debug__:
            if self.trace:
                print("%s [%s] setting %s self.trace <- %s" \
                    % (assembler.eloc(self,"pre_process",module=this_module),\
                        self.lineno,self.instu,self.trace))

        # Bubble up the operation field from the logical line to the ASMStmt
        # subclass, remembering if there are any ampersands present in the field
        self.oper_fld=oper=self.logline.oper_fld
        assert oper is not None,\
            "%s [%s] %s" % (assembler.eloc(self,"pre_process",module=this_module),\
                self.lineno,self.logline)
        if oper.amp:
            self.amp=True
            self.amp_list.append(oper)

        # Bubble up the label field from the logical line to the ASMStmt subclass,
        # remembering if there are any ampersands present in the field
        self.label_fld=lbl=self.logline.label_fld
        if lbl and lbl.amp:
            self.amp=True
            self.amp_list.append(lbl)

        # Validate the operation field as valid.  If after validation it has
        # a type of U, raise an AssemblerError.
        oper.validate(asm,self,self.__class__.ofld,debug=False)
        if oper.typ=="U":
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg="operation field unrecognized or invalid: %s" % (oper.text))

        # Validate the label field if present.  If it has a type of U now, raise
        # an AssemblerError
        if lbl:
            # Validate and set label field's type
            lbl.validate(asm,self,self.__class__.lfld,debug=False)
            if lbl.typ=="U":
                raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                    msg="label field unrecognized or invalid: %s" % (lbl.text))

        # Return the trace setting
        return trace

    # Returns a case sensitive or insensitive sequence symbol
    # Method Argument:
    #   case   Specify True for case sensitive handling.  Otherwise the sequence
    #          symbol is treated as case insensitive
    def seqsym(self,case=False):
        label=self.label_fld
        if label is None or label.typ!="Q":
            return None
        if case:
            return label.text
        return label.text.upper()

    # Parses operands LOperands objects, requiring ASMOperTyp sep=False, for simple
    # operand handling not requiring sophisticated parsing techniques.  It uses
    # simple, efficient Python string handling tools to perform the separation of
    # individual operands into a list of strings.
    # Returns:
    #   a list of strings.  The list may be of zero length if no operands are
    #   present or the operands start with a comma followed by an optional space.
    def spp_operands(self,debug=False):
        # Extract the operands field from the statement LOperands object
        if self.opnd_fld is None:
            return []

        assert isinstance(self.opnd_fld,asmline.LOperands),\
            "%s self.opnd must be asmline.LOperands object: %s" \
                % (assembler.eloc(self,"spp_operands",module=this_module),\
                    self.opnd_fld)

        operfld=self.opnd_fld.text
        # fudge a comma for no operands when a comment exists
        if len(operfld)>=2 and operfld[:2]==", ":
            return []
        elif len(operfld)==1 and operfld[0]==",":
            return []

        opers=self.spp_remove_comments(operfld)

        # Separate the operands wherever a comma occurs.
        opers=opers.split(",")      # separate operands
        if not isinstance(opers,list):
            opers=[opers,]
        return opers

    # Removes comments from a string
    # Returns:
    #   a string ending with the operand field's last character
    def spp_remove_comments(self,string):
        # Find the actual operands, ending with a possible space indicating the
        # comments field
        try:
            ndx=string.index(" ")
            opers=string[:ndx]
            # Note this bypasses the comment field processing.  So at some point
            # this method needs to be replaced to allow model statement generation
            # to incorporate any comment.  For know this is good enough.
        except ValueError:
            opers=string

        return opers  # Return the operand field from the string

    # Returns the address to be used in a structure:
    #   Absolute Address - returns the absolute address
    #   CSECT Relative - raises a AssemblerError
    #   DSECT Relative - returns the relative displacement (treating it as an integer)
    #   integer - returns the integer.
    def struct_address(self,opn,addr):
        if isinstance(addr,int):
            return addr
        if isinstance(addr,lnkbase.Address):
            if addr.isAbsolute():
                return addr.address
            if addr.isDummy():
                return addr.value
        raise assembler.MSLError(line=self.lineno,\
            msg="%s operand %s may not be CSECT relative: %s" \
                % (self.instu,opn,addr))

    # Returns a SymbolID object of the label's symbolic reference or None
    def symvar(self):
        label=self.label_fld
        if label is None or label.typ!="S":
            return None
        return label.symid

    # Validates the label field as containing a symbolic variable.  It returns
    # a unprepared macopnd.SymbolRef complex term.  This method is a call back
    # made by the asmline.LField object.
    # Exceptions:
    #   AssemblerError
    def validate_symbol(self,asm,field,debug=False):
        try:
            return asm.PM.parse_label(self,field,debug=debug)
        except assembler.AsmParserError as ape:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg=ape.msg)
        if __debug__:
            if debug:
                print("%s P0_operands: %s" \
                    % (assembler.eloc(self,"parse_sep",module=this_module),\
                        self.P0_operands))

  #
  # These methods required by each subclass
  #

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        raise NotImplementedError("subclass %s requires Pass0() method" \
            % (self.__class__.__name__))

    def Pass1(self,asm,debug=False,trace=False):
        raise NotImplementedError("subclass %s requires Pass1() method" \
            % (self.__class__.__name__))

    def Pass2(self,asm,debug=False,trace=False):
        raise NotImplementedError("subclass %s requires Pass2() method" \
            % (self.__class__.__name__))


#
#  +-------------------------------------+
#  |                                     |
#  |   Directive Shared Super Classes    |
#  |                                     |
#  +-------------------------------------+
#


# Statements processing macro parameters in a prototype or invoked macro
class ParmStmt(ASMStmt):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def find_label(self,typ):
        # Identify prototype label symbolic variable, if present
        lbl=self.label_fld
        if lbl:
            if lbl.typ==typ:
                var=lbl.text
            else:
                raise assembler.AssemblerError(line=self.lineno,\
                    msg="invalid prototype label parameter: '%s'" % lbl.text)
        else:
            var=None
        return var

    def find_parms(self,asm,proto=False,debug=False):
        try:
            parms=asm.PM.parse_sep(self)
        except macsyms.SynbolError as se:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg=se.msg) from None

        if __debug__:
            if debug:
                print("%s [%s] parms:%s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,parms))

        return parms


# SETA, SETB and SETC macro directive super class
class SETx(ASMStmt):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True    # All subclasses are macro directives

    def process(self,asm,desc,dmethod,debug=False):
        pdebug = self.pre_process(asm) or debug
        #pdebug=debug or self.trace    # TRACE if either call is TRUE or ATRACEON
        self.parse_line(asm,debug=pdebug)
        lineno=self.lineno

        setname=self.symvar()
        if __debug__:
            if pdebug:
                print("%s [%s] symvar: %s" \
                    % (assembler.eloc(self,"process",module=this_module),\
                        self.lineno,setname))

        if setname is None:
            raise assembler.AssemblerError(source=self.source,line=lineno,\
                msg="%s macro directive requires label field containing a "
                    "symbolic reference, omitted or invalid" \
                        % self.__class__.__name)

        # Parse the operands.
        self.parse_sep(asm,debug=pdebug)
        # P0_operands contains a list of asmbase.ASMOperand objects
        if __debug__:
            if pdebug:
                self.debug_list(self.P0_operands)

        # Prepare the label field for execution
        setname.prepare(self,"%s_sym" % desc)

        # Prepares each expression for execution
        exp_list=[]   # List of expression objects
        syslist=False
        for n,exp in enumerate(self.P0_operands):
            assert len(exp._secondary)==0,\
                "%s [%s] secondary expression found in operand: %s" \
                    % (assembler.eloc(self,"process",module=this_module),\
                        lineno,n)

            e=exp._primary
            if __debug__:
                if pdebug:
                    print("%s exp primary: %s" \
                        % (assembler.eloc(self,"process",module=this_module),\
                            e.display(string=True)))

            d="%s:%s" % (desc,n)
            e.prepare(self,d)
            exp_list.append(e)

        dmethod(self.lineno,setname,exp_list,syslist=self.syslist)


# POP and PUSH assembler directive super class
class StackingStmt(ASMStmt):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True     # All subclasses are assembler directives

    def stacking_operands(self,asm,debug=False):
        if self.opnd_fld is None:
            raise assemlber.AssemblerError(line=self.lineno,\
                msg="%s directive requires at least one operand" % self.instu)

        no_print=False
        stack_print=False
        stack_using=False
        operands=self.spp_operands(debug=debug)
        if len(operands)>1 and operands[-1].upper() == 'NOPRINT':
            no_print=True
            operands=operands[:-1]
        for x in operands:
            y=x.upper()
            if y=="PRINT":
                stack_print=True
            elif y=="USING":
                stack_using=True
            # Add cases here for additional future operands
            else:
                raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                    msg="%s operand invalid: %s" % (self.instu,x))

        return (stack_using,stack_print,no_print)


# GBLA, GBLB, GBLC, LCLA, LCLB, LCLC macro directive super class
class SymbolDefine(ASMStmt):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True     # All subclasses are macro directives

    def process(self,asm,typ,dmethod,debug=False):
        pdebug = self.pre_process(asm) or debug
        if __debug__:
            if pdebug:
                print("%s [%s]" \
                    % (assembler.eloc(self,"process",module=this_module),\
                        self.lineno))
        self.parse_line(asm,debug=pdebug)

        lineno=self.lineno
        source=self.source

        self.parse_sep(asm,debug=pdebug)
        # P0_operands contains a list of macopnd.SymbolRef objects
        if __debug__:
            if debug:
                self.debug_list(self.P0_operands)

        case=asm.case
        for n,sym in enumerate(self.P0_operands):
            if sym is None:
                # An empty operand in LCLx or GBLx statements is ignored
                continue

            # Otherwise must be a symbol reference
            assert isinstance(sym,macopnd.SymbolRef),\
                "%s [%s] P0_operand[%s] must be a macopnd.SymbolRef object: %s" \
                    % (assembler.eloc(self,"process",module=this_module),\
                        self.lineno,n,sym)

            if len(sym._secondary)>1:
                raise assembler.AssemblerError(source=source,line=lineno,\
                    msg="%s symbolic variable symbol %s may have only one dimension, "\
                        "found: %s" % (typ,sym.seqsym,len(sym._secondary)))

            # Prepare the CTerm for execution
            sym.prepare(self,"typ")
            refobj=sym.atoken()
            #refobj=sym.ptoken()

            # Only define the sequence name with the first definition
            if n==0:
                seq=self.seqsym()
            else:
                seq=None

            # Before presenting the definition to the macro definition process
            # expressions must be ready for execution, i.e, prepared.
            dmethod(lineno,refobj,seq=seq,syslist=self.syslist)
        return


# CCW, CCW0, CCW1, ORG, PSWS, PSW360, PSW67, PSWBC, PSWEC, PSW380, PSWXA, PSWE370,
# PSWE390, PSWZ. SPACE assembler directive super class.
class TemplateStmt(ASMStmt):
    def __init__(self,lineno,logline=None,minimum=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True       # All subclasses area assembler directives

        self.minimum=minimum   # Minimum required operands

    def ck_literals(self):
        raise NotImplementedError("%s subclass %s must provide ck_literals() method"\
            % (assembler.eloc(self,"ck_literals",module=this_module),\
                self.__class__.__name__))

    def create_bin_list(self,cls_list):
        bin_lst=[]
        for n,cls in enumerate(cls_list):
            name="I%s" % n
            clso=cls(name)
            bin_lst.append(clso)

        self.bin_oprs=bin_lst

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)
        self.ck_literals()

        self.parse_sep(asm,debug=pdebug)     # May raise assembler.AssemblerError
        # self.PO_operands is a list of ASMOperand objects
        if __debug__:
            if pdebug:
                self.debug_P0(cls=asmbase.ASMOperand)

        # Make sure the minimum required operands are in the source statement
        self.ck_min_operands(minimum=self.minimum)

        # Set up binary operand class list
        template=self.template
        # Create the list of Operand subclass instances used to create template
        # values.
        self.create_bin_list(self.__class__.template)

        # Make sure the number of source operands does not exceed those allowed
        # for the template statement.
        if len(self.P0_operands)>len(template):
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg="%s operands exceeds the number allowed for the operation, %s" \
                    % (len(self.P0_operands),len(template)))


#
#  +---------------------------+
#  |                           |
#  |   Individual Statements   |
#  |                           |
#  +---------------------------+
#

# Statement class used for all logical lines that constitute comments
class StmtComment(ASMStmt):
    typ="*"        # Statement type identifier
    lfld=""        # Valid label field content
    ofld=""        # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.comment=True
        # Whether this is a loud (False) or quite (True) comment
        self.comment=logline.comment
        self.quite=logline.quiet
        self.empty=logline.empty
        # Comments are never continued so there is only one physical line within the
        # logical line.
        self.ignore=True

    def Pass0(self,asm,macro=None,debug=False,trace=False): pass
    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# Statement class used for all logical lines in error
class StmtError(ASMStmt):
    typ="?"        # Statement type identifier
    lfld=""        # Valid label field content
    ofld=""        # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.error=logline.error    # LineError object of the logical line error
        #print("%s ERROR: %s" \
        #    % (assembler.eloc(self,"__init__",module=this_module),self.error))

    # Converts logical line error into an AssemblerError and raises it
    def le_error(self):
        if self.error.maclib:
            raise assembler.AssemblerError(line=self.lineno,msg="%s" % self.error)
        else:
            raise assembler.AssemblerError(source=self.logline.source,\
                line=self.lineno,msg=self.error.msg)

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.le_error()

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# Statement class used for all machine instructions
class MachineStmt(ASMStmt):
    # Statement processing controls
    typ="I"        # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Source statement operand types      Evaluated results of expressions
    types={"I":  asmbase.Single,          # unsigned int
           "M":  asmbase.Single,          # unsigned int
           "R":  asmbase.Single,          # unsigned int
           "V":  asmbase.Single,          # unsigned int
           "RI": asmbase.Single,          # signed int
           "RELI":asmbase.SingleRelImed,  # signed integer
           "S":  asmbase.Storage,         # addr or int(int)
           "SY": asmbase.Storage,         # addr or int(int)
           "SR": asmbase.StorageExt,      # addr or addr(integer) or int(int,int)
           "SL": asmbase.StorageExt,      # addr or addr(integer) or int(int,int)
           "SX": asmbase.StorageExt,      # addr or addr(integer) or int(int,int)
           "SYL":asmbase.StorageExt,      # addr or addr(integer) or int(int,int)
           "SYX":asmbase.StorageExt}      # addr or addr(integer) or int(int,int)
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

        # Provided by Pass1()
        self.insn=None         # Instruction cache entry (MSLentry object)
        self.format=None       # msldb.Format instance for instruction

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug or trace
        self.parse_line(asm,debug=pdebug)

        # Create machine instruction information
        msl=self.optn.info   # Extract MSLentry object from ASMOper object
        # Operands supported by the instruction
        oprs=msl.src_oprs(debug=pdebug)
        if __debug__:
            if pdebug:
                print("%s [%s] Instruction operands: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,len(oprs)))

        if oprs:
            # Only parse separated operands if operands are required
            self.parse_sep(asm,debug=pdebug)    # May raise assembler.AssemblerError
            # self.PO_operands is a list of None or ASMOperand objects
            if __debug__:
                if pdebug:
                    self.debug_P0(cls=asmbase.ASMOperand)

        # Make sure the number of source operands does not exceed those allowed
        # for the machine instruction.
        if len(self.P0_operands)>len(oprs):
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg="%s operands exceeds the number allowed for the operation, %s" \
                    % (len(self.P0_operands),len(oprs)))

        lst=[]
        for op in oprs:
            cls=MachineStmt.types[op]

            if __debug__:
                if pdebug:
                    print("%s DEBUG using Operand subclass: %s('%s')" \
                        % (assembler.eloc(self,"Pass0"),cls.__name__,op))
            clso=cls(op)
            lst.append(clso)

        self.bin_oprs=lst

    def Pass1(self,asm,debug=False,trace=False):
        insn=self.insn=self.optn.info    # Instruction cache entry (MSLentry object)
        length=insn.length     # length of the instruction in bytes

        # Create the content definition for the machine instruction
        # Always put instructions on half word boundary
        bin=assembler.Binary(2,length)

        # Assign space in the active section for the machine instruction
        asm._check_cur_sec(debug=trace)
        asm.cur_sec.assign(bin)

        # Update the stmt instance with instruction format and content information
        self.format=insn.mslformat   # msldb.Format instance
        self.content=bin             # Place in statement

        # Define the statement's label if present
        self.label_create(asm,length,T="I")    # Use binary content length
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        idebug=trace or self.trace
        etrace=asm.dm.isdebug("tracexp") or idebug
        edebug=asm.dm.isdebug("exp")

        # Update binary operands with source statement values
        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Resolve all values in preparation for machine instruction construction:
        # calculate base/displacements, relative immediate, find lengths, etc.
        operands=self.bin_oprs
        laddrs=[]
        for ndx,opr in enumerate(operands):
            opr.resolve(asm,self,ndx,trace=idebug)
            if opr.laddr is not None:
                laddrs.append(opr.laddr)

        # Figure out what should go into the ADDR1 and ADDR2 listing fields
        if len(laddrs)==1:
            #self.laddr=[laddrs[0],None]
            self.laddr=[laddrs[0],]
        elif len(laddrs)>=2:
            self.laddr=[laddrs[0],laddrs[-1]]
        else:
            self.laddr=[]

        asm.builder.build(self,trace=idebug)


# Macro Prototype Statement - Oper Type: MP
class MacroProto(ParmStmt):
    # Statement processing controls
    typ="MP"       # Statement type identifier
    lfld="B"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    parser="mproto"# Operand parser
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression (all allowed)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.pre_process(asm)
        self.parse_line(asm)

        # Identify prototype label symbolic variable, if present
        lbl=self.label_fld
        if lbl:
            if lbl.typ=="B":
                var=lbl.text
            else:
                raise assembler.AssemblerError(line=self.lineno,\
                    msg="invalid prototype label parameter: '%s'" % lbl.text)
        else:
            var=None

        # Separate parms into a list of macsysms.MacroParm objects
        try:
            parms=asm.PM.parse_sep(self)
        except macsyms.SymbolError as se:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg=se.msg) from None

        if __debug__:
            if debug:
                print("%s [%s] parms:%s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,parms))

        # Perform uniqueness tests on parameter names and separate types
        case=asm.case
        parm_names=[]
        pos_parms=[]
        key_parms={}
        for parm in parms:
            if parm.keyword:
                name=parm.keyword
                key_parms[name]=parm
            elif parm.positional:
                name=parm.positional
                pos_parms.append(parm)
            if not case:
                name=name.upper()
            if name in parm_names:
                raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                    msg="operand %s duplicate macro prototype parameter: %s" \
                        % (parm.onum+1,name))
            if name=="&SYSLIST":
                raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                    msg="operand %s &SYSLIST may not be used as a parameter name" \
                        % parm.onum+1)
            parm_names.append(name)
        # If we got here, no duplicate or prohibited parameter names detected and
        # keyword and positional parameters separated into a list and keywords into
        # a dictionary.

        proto=asmmacs.Prototype(self.instu,lblsym=var,\
            positionals=pos_parms,keywords=key_parms)

        if __debug__:
            if debug:
                print("%s starting macro:\n%s" \
                    % (assembler.eloc(self,"_prototype",module=this_module),proto))

        # Prototype statement successfully processed, can proceed with definition
        macro.indefn=asmmacs.Macro(proto,asm.case,defn=self.lineno)


# Statement class used for each invoked macro
class MacroStmt(ParmStmt):
    # Statement processing controls
    typ="M"        # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    parser="mparms"# Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression (all allowed)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

        # Pass 0
        self.macro=None       # Macro definition being invoked
        self.label=None       # Statement's label if present
        self.keywords=None    # Statement keyword parameters
        self.pos=None         # Statement postional parameters

    def legacy_fixup(self,asm):
        pass

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        self.label=self.label_optional()

        try:
            parms=asm.PM.parse_sep(self)
        except macsyms.SynbolError as se:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg=se.msg) from None

        if __debug__:
            if pdebug:
                print("%s [%s] parms:%s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,parms))

        case=asm.case
        parm_names=[]
        pos_parms=[]
        key_parms={}

        for parm in parms:
            if parm is None:
                pos_parms.append(None)
            elif parm.keyword:
                # This is a keyword parm
                name=parm.keyword
                if not case:
                    name=name.upper()
                key_parms[name]=parm
            else:
                # Positional parameter
                pos_parms.append(parm)
        self.pos=pos_parms
        self.keywords=key_parms

        # Retrieve the macro definition from ASMOper
        self.macro=self.optn.info

        # Create an asmmacs.Expander object.  The object runs the macro interpreter.
        # &SYSNDX value and MHELP limits are managed by the macstmt() method
        exp=asm.MM.macstmt(self)
        if exp is None:  # This means MHELP maximum sysndx has been reached
            self.ignore=True
            return       # Silently ignore the macro statement

        # Create a new input source, that is, the macro being invoked
        asm.IM.newMacro(exp,stmtno=self.lineno)
        # Done with the macro statement that triggered the expansion.
        # The macro engine now runs under control of the LineBuffer with the new
        # macro input source.
        self.ignore=True


# Generic model statement
class ModelStmt(ASMStmt):
    # Statement processing controls
    typ="MG"       # Statement type identifier
    lfld="MLSQ"    # Valid label field content
    ofld="LS"      # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    #parser="mopnd" # Operand parser used by statement
    parser=None    # Operand parser used by statement (invoked by model.Model)
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Allow the same attributes in model statements as open code

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.model=None      # model.Model object used for all processing
        self.syslist=False   # Whether &SYSLIST required.
        self.mdebug=False    # Manually change to enable debugging

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        mdebug=self.mdebug=self.mdebug | debug | trace
        indefn=self.ck_in_macro_defn(macro,2,"model")
        m=model.Model(asm,self,debug=debug)

        if m.loud:
            # Nothing to do for a loud comment and they can't have a sequence symbol
            seq=None
        else:
            self.pre_process(asm)
            self.parse_line(asm,debug=mdebug)
            if __debug__:
                if mdebug:
                    print("%s stmt label fld: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.label_fld))
                    print("%s line label fld: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.logline.label_fld))
                    print("%s stmt oper  fld: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.oper_fld))
                    print("%s line oper  fld: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.logline.oper_fld))

            seq=self.seqsym(asm.case)
            if __debug__:
                if mdebug:
                    print("%s model: '%s'"\
                        % (assembler.eloc(self,"Pass0",module=this_module),model))

            m.parse(asm,self,debug=mdebug)

        self.model=m

        indefn._model(\
            self.lineno,self.model,seq=seq,syslist=self.syslist,debug=mdebug)


#
#  +---------------------------+
#  |                           |
#  |   Individual Directives   |
#  |                           |
#  +---------------------------+
#

# ACTR Macro Directive - Oper Type: MO
class ACTR(ASMStmt):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    # Parse operand expression - called by MacroLanguage
    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"ACTR")
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        if len(self.operands)!=1:
            raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                msg="ACTR directive requires one operand, found: %s" \
                    % len(self.operands))

        self.parse_sep(asm,debug=pdebug)
        # PO_operands is a list of one asmbase.ASMOperand object
        expr=self.P0_operands[0]       # expr is an asmbase.ASMExprArith object
        assert len(expr._secondary)==0,\
            "%s [%s] secondary expression found in operand: %s" \
                % (assembler.eloc(self,"process",module=this_module),lineno,n)

        e=expr._primary
        e.prepare(self,"ACTR")

        # Add the operation to the macro definition
        indefn._actr(self.lineno,e,seq=self.seqsym(asm.case))

    # Pass1 - should never be called
    # Pass2 - should never be called

# AGO Macro Directive - Oper Type: MO
#
# Unconditional pass control to a sequence symbol in a macro definition
#
# [.seqsym] AGO  .seqsym
#
# Or, in a macro definition, unconditionally pass control to a sequence symbol
# selected by computation.
#
# [.seqsym] AGO  [(arithmetic-expression)].seqsym[,seqsym...]

class AGO(ASMStmt):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"AGO")
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        lineno=self.lineno
        if len(self.operands)==0:
            raise assembler.AssemblerError(line=lineno,source=self.source,\
                msg="AGO directive requires at least one operand")

        pm=asm.PM
        case=asm.case
        try:
            result=pm.parse_ago(self,self.operands[0],debug=pdebug)
        except assembler.AsmParserError as ape:
            raise assembler.AssemblerError(source=self.source,line=lineno,\
                msg=ape.msg) from None

        seq=self.seqsym(case)     # Statement sequence symbol or None

        # Result is a macopnd.CondBranch object
        if result._primary is None:
            # This is an unconditional transfer of control
            if len(self.operands)>1:
                raise assembler.AssemblerError(source=self.source,line=lineno,\
                    msg="unconditional AGO requires one operand, found: %s" \
                        % len(self.operands))

            if not case:
                target=result._target.upper()
            else:
                target=result._target
            indefn._ago(lineno,target,seq=seq)
            return

        # This is a computed AGO...

        # Extract the arithmtic expression of the computed AGO form the CondBranch
        # result object
        expr=result._primary
        expr.prepare(self,"ago")
        # Arithmetic expression ready for the macro operation

        # Extract the first target from the CondBranch object and start the
        # target destination list
        if not case:
            target=result._target.upper()
        else:
            target=result._target
        dest=[target,]       # Start list of computed target sequence symbols

        # Process the remaining operands for additional target sequence symbols.
        # Note n is relative to the second operand
        for n,opnd in enumerate(self.operands[1:]):
            try:
                seqsym=pm.parse_seqsym(self,opnd,debug=pdebug)
            except assembler.AsmParserError as ape:
                raise assembler.AssemblerError(source=self.source,line=lineno,\
                    msg=ape.msg) from None

            # seqsym is a list of tokens (one) of the recognized sequnce symbol
            assert len(seqsym)==1,\
                "%s [%s] operand %s seqsym list, parse_seqsym() result object, "\
                    "contains more than one token: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            lineno,n+2,seqsym)
            target=seqsym[0]
            assert isinstance(target,asmtokens.LexicalToken) \
               and target.tid=="SEQSYM",\
                "%s [%s] operand %s target not an SEQSYM lexical token: %s"\
                    % (assembler.eloc(self,"Pass0",module=this_module),lineno,n+2,\
                        target)

            target=target.string
            if not case:
                target=target.upper()
            else:
                target=target
            dest.append(target)

        indefn._agoc(lineno,dest,expr,seq=seq,syslist=self.syslist)

    # Pass1 - should never be called
    # Pass2 - should never be called


# AIF Macro Directive
#
# Conditional passes control to a sequence symbol in a macro definition
#
# [.seqsym] AIF   (<binary-expression>).seqsym

class AIF(ASMStmt):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    #attrs="KNTD"   # Attributes supported in expression
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"AIF")
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        lineno=self.lineno
        if len(self.operands)==0:
            raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                msg="AIF directive requires at least one operand")

        self.parse_sep(asm,debug=pdebug)
        # P0_operands contains a list of macopnd.CondBranch objects
        if __debug__:
            if debug:
                self.debug_list(self.P0_operands)

        pm=asm.PM
        case=asm.case
        for n,opnd in enumerate(self.P0_operands):
            assert isinstance(opnd,macopnd.CondBranch),\
                "%s [%s] P0_operand[%s] must be a macopnd.CondBranch object: %r" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,n,opnd)

            expr=opnd._primary
            expr.prepare(self,"aif")
            if not case:
                target=opnd._target.upper()
            else:
                target=opnd._target

            # Only define the sequence name with the first conditional branch
            if n==0:
                seq=self.seqsym(case)
            else:
                seq=None

            indefn._aif(lineno,target,expr,seq=seq,syslist=self.syslist)

    # Pass1 - should never be called
    # Pass2 - should never be called


# AMODE Assembler Directive - Oper Type: SPP
#
# Set a control-section's address mode
#
# [CSECT] AMODE 24|31|64|ANY|ANY31|ANY64

class AMODE(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.ignore=True         # Treat as a comment

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# ANOP Macro Directive - Oper Type: MO
#
# Macro no-operation
#
# [.seqsym] ANOP  [comments]

class ANOP(ASMStmt):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    # Parse operand expression - called by MacroLanguage
    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"ANOP")
        self.pre_process(asm)
        indefn._anop(self.lineno,seq=self.seqsym(asm.case))

    # Pass1 - should never be called
    # Pass2 - should never be called


# ATRACEOFF Assembler Directive - Oper Type SPP
#
# Disable tracing of one or more operations
#
# [label] ATRACEOFF oper[,oper]...

class ATRACEOFF(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        mytrace = self.pre_process(asm) or debug
        self.parse_line(asm,debug=mytrace)

        operfld=self.opnd_fld    # LOperands object
        #if __debug__:
        #    mytrace=

        # Operations not already enabled for tracing are silently ignored.
        operands=self.spp_operands()
        if len(operands)==0:
            if __debug__:
                if mytrace:
                    print("%s [%s] no operands, statement ignored" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.lineno))
            self.ignore=True
            return

        # Disable operation tracing
        # Operations not already enabled for tracing are silently ignored
        for op in operands:
            opuc=op.upper()
            try:
                asm.otrace.remove(opuc)
                if __debug__:
                    if mytrace:
                        print("%s [%s] tracing disabled for operation: %s" \
                            % (assembler.eloc(self,"Pass0",module=this_module),\
                                self.lineno,op))
            except ValueError:
                if __debug__:
                    if mytrace:
                        print("%s [%s] ignoring, operation not enabled for "
                            "tracing: %s" \
                            % (assembler.eloc(self,"Pass0",module=this_module),\
                                self.lineno,op))
                pass

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# ATRACEON Assembler Directive - Oper Type SPP
#
# Enable tracing of one or more operations
#
# [label] ATRACEON oper[,oper]...

class ATRACEON(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assemlber directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        mytrace = self.pre_process(asm) or debug
        self.parse_line(asm,debug=mytrace)

        operands=self.spp_operands()

        # If no operands, dump the current oper trace table to sysout
        if len(operands)==0:
            # a string of length zero or None both are treated as False
            print("[%s] Operation trace table:" % self.lineno)
            for x in asm.otrace:
                print("     %s" % x)
            return

        # Operands present so set them
        otrace=asm.otrace
        for op in operands:
            opuc=op.upper()
            if opuc in otrace:
                if __debug__:
                    if mytrace:
                        print("%s [%s] tracing already enabled for operation: %s" \
                            % (assembler.eloc(self,"Pass0",module=this_mdoule),\
                                self.lineno,op))
                continue
            otrace.append(opuc)
            if __debug__:
                if mytrace:
                    print("%s [%s] enabled tracing of operation: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.lineno,op))

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# CCW0 Assembler Directive - Oper Type: TPL
#
# Build a Channel Command Word Format-0
#
# [label] CCW0    command,address,flags,count

class CCW0(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.SingleAny,asmbase.Single,asmbase.Single]

    #
    #  CCW and CCW0 Templates
    #

    @classmethod
    def structure(cls,builder):
        fields=[insnbldr.Field(value=None,name="CCW0 command code",size=8,start=0),
            insnbldr.Field(value=None,name="CCW0 address",size=24,start=8),
            insnbldr.Field(value=None,name="CCW0 flags",size=8,start=32),
            insnbldr.Field(value=None,name="CCW0 byte count",size=16,start=48)]
        cls.struct=Structure("CCW0",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals(allowed=[1,])

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        idebug=trace or self.trace

        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="W",debug=idebug)

        # Update the current location counter
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        idebug=trace or self.trace
        etrace=asm.dm.isdebug("tracexp") or idebug
        edebug=asm.dm.isdebug("exp")

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract CCW/CCW0 operand values after expression evalution
        code=self.bin_oprs[0].getValue()
        address=self.bin_oprs[1].getValue()
        flags=self.bin_oprs[2].getValue()
        count=self.bin_oprs[3].getValue()

        ccwflags=flags & 0xFE # Make sure bit 39 is zero

        inst=self.instu

        # Validate CCW/CCW0 Address - Operand 2
        if isinstance(address,lnkbase.Address):
            if not address.isAbsolute():
                raise asssembler.AssemblerError(line=self.lineno,\
                    msg="%s operand 2 result must be an absolute address: %s" \
                        % (inst,address))
            ccwaddr=address.address
        else:
            ccwaddr=address

        # Build an insnbldr.Field object for each CCW field

        # Build the CCW or CCW0 content
        values=[code,ccwaddr,ccwflags,count]
        bytes=CCW0.struct.build(self,values,trace=trace)
        # Update the statements binary content with the CCW0
        self.content.update(bytes,at=0,full=True,finalize=True,trace=idebug)

        # Update the current location counter
        asm.cur_loc.increment(self.content)


# CCW1 Assembler Directive - Oper Type TPL
#
# Build a Channel Command Word Format-1
#
# [label] CCW1    command,address,flags,count

class CCW1(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.SingleAny,asmbase.Single,asmbase.Single]

    #
    #  CCW1 Template
    #

    @classmethod
    def structure(cls,builder):
        fields=[insnbldr.Field(value=None,name="CCW1 command code",size=8,start=0),
                insnbldr.Field(value=None,name="CCW1 flags",size=8,start=8),
                insnbldr.Field(value=None,name="CCW1 byte count",size=16,start=16),
                insnbldr.Field(value=None,name="CCW1 address",size=31,start=33)]
        cls.struct=Structure("CCW1",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals(allowed=[1,])

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        idebug=trace or self.trace

        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="W",debug=idebug)
        # Update the current location counter
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        idebug=trace or self.trace
        etrace=asm.dm.isdebug("tracexp") or idebug
        edebug=asm.dm.isdebug("exp")

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract CCW1 operand values after expression evalution
        code=self.bin_oprs[0].getValue()
        address=self.bin_oprs[1].getValue()
        flags=self.bin_oprs[2].getValue()
        count=self.bin_oprs[3].getValue()

        ccwflags=flags & 0xFE   # Make sure bit 15 is 0

        # Validate CCW1 Address - Operand 2
        if isinstance(address,lnkbase.Address):
            if not address.isAbsolute():
                raise assembler.AssemblerError(line=self.lineno,\
                    msg="CCW1 operand 2 result must be an absolute address: %s" \
                        % address)
            ccwaddr=address.address
        else:
            ccwaddr=address

        # Build the CCW1 content
        values=[code,ccwflags,count,ccwaddr]
        bytes=CCW1.struct.build(self,values,trace=trace)
        # Update the statements binary content with the CCW1
        self.content.update(bytes,at=0,full=True,finalize=True,trace=idebug)
        # Update the current location counter
        asm.cur_loc.increment(self.content)


# CNOP Assembler Directive - Oper Type TPL
#
# Aligns to a halfwoed selected byte within a boundary
#
# [label] CNOP   byte,boundary

class CNOP(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    template=[asmbase.Single,asmbase.Single]

    # Valid byte values for a given boundary
    valid_bytes={4:[0,2,4],8:[0,2,4,6,8],16:[0,2,4,6,8,10,12,14,16]}

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=2)

        # Pass 0
        self.new_symbol=None   # New symbol being created

        # Pass 1
        self.nops=0            # Number of NOP's to generate in Pass 2

    def ck_literals(self):
        self.ck_for_literals() # No literals allowed

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        etrace=trace or self.trace
        super().Pass0(asm,debug=debug,trace=etrace)

        if len(self.P0_operands)!=2:
            raise AssemblerError(source=self.source,line=self.line,\
                msg="CNOP operation requires two (2) operands, found: %s" \
                    % len(self.P0_operands))

    def Pass1(self,asm,debug=False,trace=False):
        etrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or etrace

        if __debug__:
            if etrace:
                print("%s [%s] CNOP current location counter: %s" % \
                    (assembler.eloc(self,"Pass1"),self.lineno,asm.cur_loc.location))

        self.evaluate_operands(asm,debug=edebug,trace=etrace)
        byte=self.bin_oprs[0].getValue()       # byte operand integer value
        boundary=self.bin_oprs[1].getValue()   # boundary operand integer value

        # Validate byte/boundary combination.
        try:
            good_bytes=CNOP.valid_bytes[boundary]
        except KeyError:
            raise AssemblerError(source=self.source,line=self.lineno,\
                msg="CNOP operation boundary operand, second operand, must be "
                    "4, 8, or 16: %s" % boundary)
        if byte not in good_bytes:
             raise AssemblerError(source=self.source,line=self.lineno,\
                msg="CNOP operation byte operand, first operand, must be "
                    "an even value between 2 and %s, inclusive: %s" \
                        % (boundary,byte))

        # Make sure there is CSECT to put something
        asm._check_cur_sec(debug=etrace)

        # Determine where we are in the section.
        cur_sec=asm.cur_sec
        disp=cur_sec.current()-cur_sec.loc
        if __debug__:
            if etrace:
                print("%s [%s] CNOP displacement into section: %s" % \
                    (assembler.eloc(self,"Pass1"),self.lineno,disp))

        more=0
        cbound,inbound=divmod(disp,boundary)
        if inbound>byte:
            next=boundary-inbound
            more=byte
        else:
            next=0
            more=byte-inbound
        needed=next+more
        nops=needed//2

        if __debug__:
            if etrace:
                print("%s [%s] CNOP: byte:%s boundary:%s disp:%s cbound:%s "
                    "inbound:%s next:%s more:%s needed:%s nops:%s" \
                        % (assembler.eloc(self,"Pass1",module=this_module),\
                            self.lineno,byte,boundary,disp,cbound,inbound,next,\
                                more,needed,nops))

        self.nops=nops    # Remember how many to generate in Pass 2

        # Note: we do not use self.new_content() method because the length would be
        # that of the generated NOP's.  CNOP labels always have a length of 1

        # Create Binary instance for the new content
        bin=assembler.Binary(2,nops*2)
        # Establish the content for this statement
        self.content=bin
        # Assign to it its '*' value
        asm.cur_sec.assign(bin)
        # Current location counter is start of binary with a section relative address

        self.label_create(asm,length=1,T="I")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        # Generate the needed BCR 0,0 instructions
        nops=[]
        for n in range(self.nops):
            nops.extend([7,0])
        barray=bytes(nops)

        bin=self.content    # Get my Binary from Pass 1
        bin.update(barray,at=0,full=True,finalize=True,trace=trace)


# COPY Assembler Directive - Oper Type: SPP
#
# Insert into the input stream the contents of a file
#
# [label] COPY  'path/filename'

class COPY(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    filename=re.compile(r"'[^' ]*'")
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.pre_process(asm)
        self.parse_line(asm,debug=debug)

        if self.opnd_fld is None:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg="%s operation requires a file name operand, omitted" \
                    % self.instu)

        operfld=self.spp_remove_comments(self.opnd_fld.text)
        mo=COPY.filename.match(operfld)
        if mo is None:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg="%s operation file name not recognized" % self.instu)
            return
        filename=operfld[mo.start():mo.end()]     # "'copy file name'"
        fname=filename[1:-1]   # remove single quotes "copy file name"
        asm.IM.newFile(fname,stmtno=self.lineno)
        self.ignore=True

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# CSECT Assembler Directive - Oper Type: SPP
#
# Start or continue a control section
#
# [label] CSECT   # no operands
class CSECT(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True       # This is an assembler directive

        self.csect=None        # Name of new or continued section or None if unnamed
        self.for_pass2=None    # Pass information to Pass2 from Pass1

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm)

        self.csect=self.label_optional()

    def Pass1(self,asm,debug=False,trace=False):
        cdebug=trace or self.trace

        csect_name=self.csect   # Fetch the CSECT name from the label field
        if __debug__:
            if cdebug:
                print("%s [%s] CSECT statement name: %s" \
                    % (assembler.eloc(self,"_csect_pass1",module=this_module),\
                        self.lineno,csect_name))

        if csect_name is None:
            # No label, so the unnamed CSECT is being targeted
            if __debug__:
                if cdebug:
                    print("%s self.unname_sec: %s" \
                        % (assembler.eloc(self,"_csect_pass1",module=this_module),\
                            asm.unname_sec))

            if asm.unname_sec is None:
                # Create the unnamed CSECT if it does not exist
                csect=asm._csect_unname(debug=cdebug)
                asm.unname_sec=csect
            else:
                # Continue the existing unnamed CSECT
                csect=asm.unname_sec
        else:
            # Label is present, so targeting a named CSECT
            try:
                csect=asm._csect_ref(self,csect_name)
                # Continuing an existing CSECT
            except KeyError:
                # Create a new named CSECT
                csect=asm._csect_new(self.lineno,csect_name,debug=cdebug)

        # Make the found or newly created CSECT the active section
        asm._csect_activate(csect,debug=cdebug)
        self.for_pass2=csect

    def Pass2(self,asm,debug=False,trace=False):
        # Set up information for listing
        csect=self.for_pass2
        addr1=csect.loc
        addr2=addr1+max(len(csect)-1,0)
        self.laddr=[addr1,addr2]


# DC Assembler Directive - Oper Type: SSP
#
# Define one or more constants
#
# [label] DC   desc'values',...

class DC(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive
        self.dc=True             # Assume here this is a DC operation

        # Pass 0
        self.gscope=None         # Finalized scope object at end of Pass 0
        self.dcds_opnds=[]       # DCDS_Operand objects

        # Pass 1
        self.values=[]           # Nominal or DCDS_Operand objects

    # This method builds the binary Area object that holds the nominal values of
    # the constant operands.  It is shared with the LiteralStmt object
    # Method Arguments:
    #   asm      the global assembler.Assembler object
    #   values   a list of Nominal objects
    # Returns:
    #   The first Nominal object upon which label attributes are based.
    def buildArea(self,asm,values,debug=False):
        area=assembler.Area()
        cur_sec=asm.cur_sec

        # Assemble each nominal value or storage allocation.
        for value in values:
            # value is either a asmfsmcs.DCDS_Operand or asmdcds.Nominal object.
            if __debug__:
                if debug:
                    print("%s operand: %s" \
                        % (assembler.eloc(self,"buildArea",module=this_module),value))

            # Note: both asmfsmcs.DCDS_Operand and asmdcds.Nominal support the
            # align() and length() methods so that they can both be the basis
            # of binary object.
            if isinstance(value,asmdcds.DCDS_Operand):
                bin=assembler.Binary(value.align(),0)
            else:
                bin=assembler.Binary(value.align(),value.length())
            cur_sec.assign(bin)

            if __debug__:
                if debug:
                    print("%s cur_sec %s _alloc=%s" \
                        % (assembler.eloc(self,"buildArea",module=this_module),\
                            cur_sec,cur_sec._alloc))

            area.append(bin)
            value.content=bin
            #if __debug__:
            #    if isinstance(value,asmdcds.Nominal):
            #        assert isinstance(value.content.barray,bytearray),\
            #            "%s [%s] value does not contain bytearray: %s" \
            #                % (assembler.eloc(self,"Pass1",module=this_module),\
            #                    self.lineno,value.content.barray)

            if __debug__:
                if debug:
                    print("%s value.content: %s" \
                        % (assembler.eloc(self,"buildArea",module=this_module),\
                            value.content))

        area.fini(trace=debug)
        # Note the binary images in the area object are also linked to the Section
        # object via its elements list.

        # Update location counter alignment (Note pass processing updates for the
        # length
        asm.cur_loc.establish(area.loc)

        if __debug__:
            if debug:
                print("%s [%s] area: %s" \
                    % (assembler.eloc(self,"buildArea",module=this_module),\
                        self.lineno,area))
                print("%s [%s] current location counter: %s" % \
                    (assembler.eloc(self,"buildArea",module=this_module),\
                        self.lineno,asm.cur_loc.location))

        self.content=area

        # Define the statement's label, if present, using the length and location
        # of the initial nominal value. (In this case the location of the initial
        # nominal value is the same as the location of the Area object.)
        first=values[0]
        if __debug__:
            if debug:
                print("%s first operand (%s): T:%s S:%s I:%s" \
                    % (assembler.eloc(self,"Pass1",module=this_module),\
                        first.__class__.__name__,first.T,first.S,first.I))
        return first

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        # This method is shared with the DS subclass
        pm=asm.PM

        opnd=self.opnd_fld
        if opnd is None:
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                msg="required operand field missing")

        try:
            self.gscope=pm.parse_constants(self,opnd.text)
        except assembler.AsmParserError as ape:
            lpos=self.opnd_fld.ndx2loc(ape.token.linepos)
            raise assembler.AssemblerError(source=self.source,line=self.lineno,\
                linepos=lpos.pndx+1,msg=ape.msg) from None

        operands=self.dcds_opnds=self.gscope.operands

        # Use scope to complete Pass 0
        dc=self.dc
        for n,oprnd in enumerate(operands):
            # This call may raise an assembler.AssemblerError
            oprnd.Pass0(self,pm,n+1,dc,update=self.opnd_fld)

    def Pass1(self,asm,debug=False,trace=False):
        # This method is shared with the DS subclass
        edebug=otrace=False
        if __debug__:
            cls_str=assembler.eloc(self,"Pass1",module=this_module)
            otrace=trace or self.trace or asm._is_otrace("ds")
            edebug=asm.dm.isdebug("exp")

        # Make sure we have an active current section before doing anything more
        asm._check_cur_sec(debug=otrace)

        gscope=self.gscope

        # Unroll operands into a series of Nominal objects.
        values=[]
        for oprnd in self.dcds_opnds:
            if __debug__:
                if otrace:
                    print("%s [%s] oprnd: %s" \
                        % (assembler.eloc(self,"Pass1",module=this_module),\
                            self.lineno,oprnd))
            values.extend(oprnd.Pass1(self,asm,debug=debug,trace=otrace))
        self.values=values
        # values is a list of asmdcds.Nominal objects.

        # If the statement truly has no operands, that is an error that should
        # have been detected long before here.  This suggests a problem with
        # the Pass0 and/or Pass1 processing in asmdcds.DCDS_Scope or
        # asmdcds.DCDS_Operand objects.
        assert len(values)>0,\
            "%s [%s] DC/DS statement failed to produce values" \
                % (asembler.eloc(self,"Pass1",module=this_module),self.lineno)

        if __debug__:
            if otrace:
                for item in values:
                    print("%s - %r" % (item,item))

        first=self.buildArea(asm,values,debug=otrace)

        self.label_create(asm,length=first.length(),T=first.T,S=first.S,I=first.I)
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        edebug=etrace=False
        if __debug__:
            edebug=asm.dm.isdebug("exp")
            etrace=asm.dm.isdebug("tracexp") or trace or self.trace
            cls_str=assembler.eloc(self,"Pass2",module=this_module)

        for n,value in enumerate(self.values):
            if __debug__:
                if etrace:
                    print("%s [%s] %s" % (cls_str,self.lineno,value))

            # Build and store image content in Binary
            try:
                value.build(self,asm,n,debug=edebug,trace=etrace)
            except fp.FPError as fe:
                # Floating point tools may raise a FPError.
                # Convert it into an AssemblerError.
                raise assembler.AssemblerError(line=self.lineno,\
                    msg="nominal value %s %s" % (n+1,fe.msg)) from None

        if __debug__:
            if trace:
                print(self.content.elements)

        asm.dcs.append(self)  # remember to fill in my binary data for the listing


# DROP Assembler Directive - Oper Type: TPL
#
# Remove a previous base register assignment
#
# [label] DROP   reg (1-16 operands allowed)

class DROP(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single]

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=1)

    def ck_literals(self):
        self.ck_for_literals()      # No literals allowed

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        self.new_content(asm,debug=debug)

    def Pass2(self,asm,debug=False,trace=False):
        dtrace=trace or self.trace
        etrace=asm.dm.isdebug("tracexp") or dtrace
        edebug=asm.dm.isdebug("exp")
        if __debug__:
            if dtrace:
                cls_str=assembler.eloc(self,"Pass2",module=this_module)
                print("%s %s operands: %s" \
                    % (cls_str,self.inst,self.operands))

        self.evaluate_operands(asm,debug=edebug,trace=etrace)
        regs=[]
        for x in range(len(self.operands)):
            if dtrace:
                print("%s register operand number: %s" % (cls_str,x))
            reg=self.bin_oprs[x].getValue()
            regs.append(reg)

        if __debug__:
            if dtrace:
                print("%s bases being dropped for registers: %s" % (cls_str,regs))

        for r in regs:
            asm.bases.drop(r,trace=dtrace)

        if __debug__:
            if dtrace:
                print("%s\n%s" % (cls_str,asm.bases.print(indent="    ",string=True)))


# DS Assembler Directive - Oper Type: SPP
#
# Define uninitialized storage
#
# [label] DS   desc'values',...

class DS(DC):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.dc=False    # Override super class assumption of DC

    # Pass 0 uses DC.Pass0() method
    # Pass 1 uses DC.Pass1() method

    def Pass2(self,asm,debug=False,trace=False):
        dtrace=False
        if __debug__:
            dtrace=trace or self.trace or asm._is_otrace("ds")
            if dtrace:
                print("%s [%s] area: %s" \
                    % (assembler.eloc(self,"Pass2",module=this_module),\
                        self.lineno,self.content))

        asm.cur_loc.establish(self.content.loc,debug=dtrace)


# DSECT Assembler Directive - Oper Type: SPP
#
# DSECT - start of continue a dummy section
#
# label DSECT   # no operands

class DSECT(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

        # Pass0
        self.dsect=None          # DSECT being started or continued

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.pre_process(asm)
        #self.parse_line(asm)

        self.dsect=self.label_required()

    def Pass1(self,asm,debug=False,trace=False):
        cls_str=assembler.eloc(self,"Pass1",module=this_module)
        ddebug=trace or self.trace

        dsect_name=self.dsect    # Fetch the DSECT name found in Pass0

        try:
            dsect=asm._dsect_ref(self,dsect_name)
            # Continuing an existing DSECT
        except KeyError:
            # Starting a new DSECT
            dsect=asm._dsect_new(self.lineno,dsect_name,debug=ddebug)

        # Make the found or newly created CSECT the active section
        asm._dsect_activate(dsect,debug=ddebug)

    def Pass2(self,asm,debug=False,trace=False): pass


# EJECT Assembler Directive - Oper Type: PD
#
# Introduce a new page in the listing (with the current title)
#
# [label] EJECT   # operands ignored if present

class EJECT(ASMStmt):
    # Statement processing controls
    typ="PD"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive
        self.prdir=True          # This is also a print directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.pre_process(asm)
        self.prdir=True
        self.ignore=True

    def Pass1(self,asm,debug=False,trace=False):pass
    def Pass2(self,asm,debug=False,trace=False):pass


# END Assembler Directive - Oper Type: SPP
#
# Terminate the assembly and assign the output image to the label field symbol
# if present.
#
# [label] END     [entry]

class END(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

        # Pass 0
        self.scope=None          # Scope object returned from parse
        self.pool=None           # Literal pool created after END directive
        self.align=None          # Alignment required by the pending literal pool.

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug

        # Create the literal pool if one is pending before any exceptions might
        # happen here.  The pool is injected into the input stream here.
        self.pool,self.align=self.literal_pool_create(asm,debug=pdebug)
        if self.pool:
            # Perform alignment for the pool if one is pending
            self.new_content(asm,alignment=self.align,length=0)

        # Regardless of any errors with the operand...
        asm.IM.end()      # ...tell Line Buffer, no more input

        # Parse END operand and comment fields per Statement Processing Controls
        self.parse_line(asm,debug=pdebug)
        # Parse the operand
        self.scope=asm.PM.parse_operands(self,"addr",required=False)

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False):
        scope=self.scope
        if scope is None:
            # No entry address, so nothing to do
            return
        # Calculate entry address
        desc="END %s" % self.lineno
        expr=asm.PM.L2ArithExpr(desc,self,ltoks=scope.lextoks)

        try:
            asm.entry=entry=expr.evaluate(asm,debug=False,trace=trace)
        except lnkbase.AddrArithError as ae:
            raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                msg="operand 1 %s" % ae.msg) from None
        except assembler.LabelError as le:
            raise assembler.AssemblerError(line=self.lineno,source=self.source,\
                msg="operand 1 undefined label: %s" % le.label) from None

        self.laddr=[None,entry]


# ENTRY Assembler Directive - Oper Type: TPL
#
# Define and report an entry-point of the image.
#
# [label] ENTRY  <address>

class ENTRY(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    template=[asmbase.SingleAddress,]

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=1)

        self.entry_label=None

    def ck_literals(self):
        self.ck_for_literals()   # No literals allowed

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=0,length=0)

    def Pass2(self,asm,debug=False,trace=False):
        idebug=trace or self.trace
        etrace=asm.dm.isdebug("tracexp") or idebug
        edebug=asm.dm.isdebug("exp")

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        entry=self.bin_oprs[0].getValue()
        self.laddr[0]=entry       # Print the value in the listing in ADDR1
        asm.entry=entry           # Report this value to the assembler


# EQU  Assembler Directive - Oper Type: TPL
#
# Defines a symbol:
#
# label EQU     expression

class EQU(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    template=[asmbase.SingleAny,asmbase.Single]

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=1)

        # Pass 0
        self.new_symbol=None   # New symbol being created

    def ck_literals(self):
        self.ck_for_literals()

    def find_root_symbol(self,asm,debug=False):
        operand1=self.operands[0]

        val_opnd=self.bin_oprs[0]
        assert isinstance(val_opnd,asmbase.Operand),\
            "%s [%s] %s EQU first statement operand not an Operand object: %s" \
                % (assembler.eloc(self,"find_root_symbol",module=this_module),\
                    self.lineno,self.source,operand1)
        val_expr=val_opnd.exprs[0]
        assert isinstance(val_expr,asmbase.ASMExpr),\
            "%s [%s] %s EQU first statement operand not an Operand object: %s" \
                % (assembler.eloc(self,"find_root_symbol",module=this_module),\
                    self.lineno,self.source,val_opnd)

        tok=val_expr.find_first_ptok(self.lineno,\
            cls=[asmtokens.PLitLabel,asmtokens.PLitLabelAttr,asmtokens.PLitCur],\
            debug=debug)

        assert tok is not None,\
            "%s [%s] %s EQU looked for root symbol token but none found" \
                % (assembler.eloc(self,"find_root_symbol",module=this_module),\
                    self.lineno,self.source)
        return tok

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        etrace=trace or self.trace
        super().Pass0(asm,debug=debug,trace=etrace)
        self.new_symbol=self.label_required()

    def Pass1(self,asm,debug=False,trace=False):
        etrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or etrace

        if __debug__:
            if etrace:
                print("%s [%s] EQU current location counter: %s" % \
                    (assembler.eloc(self,"Pass1"),self.lineno,asm.cur_loc.location))

        # Update statement with current location information
        self.location=self.p1_loc=asm.cur_loc.retrieve()

        self.evaluate_operands(asm,debug=edebug,trace=etrace)
        new_symbol=self.new_symbol
        val_expr=self.bin_oprs[0]      # val_expr is a asmbase.Operand object

        new_length=None
        if len(self.operands)==2:
            new_length=self.bin_oprs[1].getValue()
        new_value=val_expr.getValue()
        if isinstance(new_value,lnkbase.SectAddr):
            if __debug__:
                if etrace:
                    print("%s [%s] %s\n    adding to asm.equates: %s %s" \
                        % (assembler.eloc(self,"Pass1",module=this_module),\
                            self.lineno,self.logline.plines[0],new_value,\
                                new_value.r))
            asm.equates.append(new_value)
        if isinstance(new_value,lnkbase.Address):
            # If there is not an explicit length, the new symbol gets its length
            # from the symbol upon which the value is based.  This symbol is the
            # one specified by the first symbol in the expression.
            if new_length is None:
                ptok=self.find_root_symbol(asm,debug=etrace)
                if isinstance(ptok,asmtokens.PLitCur):
                    new_length=1
                else:
                    ste=asm._getSTE_Ref(ptok.label,self.lineno)
                    new_length=ste["L"]
        elif isinstance(new_value,int):
            if new_length is None:
                new_length=1
        else:
            raise ValueError("%s EQUATE new_value unexpected: %s" \
                % (assembler.eloc(self,"Pass1",module=this_module),new_value))

        new_ste=assembler.LabelSymbol(new_symbol,new_value,length=new_length)
        asm._symbol_define(new_ste,self.lineno)
        self.laddr=[new_value,new_length]

    def Pass2(self,asm,debug=False,trace=False): pass


# GBLA Macro Directive - Oper Type: MO
#
# Define one or more global arithmetic symbolic variables
#
# [seq]  GBLA  &sym,&syma(a-expr),...

class GBLA(SymbolDefine):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"GBLA")
        self.process(asm,"GBLA",indefn._gbla,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# GBLB Macro Directive - Oper Type: MO
#
# Define one or more global binary (logical) symbolic variables
#
# [seq]  GBLB  &sym,&symb(a-expr),...

class GBLB(SymbolDefine):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"GBLB")
        self.process(asm,"LCLB",indefn._gblb,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# GBLC Macro Directive - Oper Type: MO
#
# Define one or more global character symbolic variables
#
# [seq]  GBLC  &sym,&symb(a-expr),...

class GBLC(SymbolDefine):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"GBLC")
        self.process(asm,"GBLC",indefn._gblc,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# LCLA Macro Directive - Oper Type: MO
#
# Define one or more local arithmetic symbolic variables
#
# [seq]  LCLA  &sym,&syma(a-expr)

class LCLA(SymbolDefine):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"LCLA")
        self.process(asm,"LCLA",indefn._lcla,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# LCLB Macro Directive - Oper Type: MO
#
# Define one or more local binary (logical) symbolic variables
#
# [seq]  LCLB  &sym,&symb(a-expr),....

class LCLB(SymbolDefine):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"LCLC")
        self.process(asm,"LCLB",indefn._lclb,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# LCLC Macro Directive - Oper Type: MO
#
# Define one or more local character symbolic variables
#
# [seq]  LCLC  &sym,&symb(a-expr),...
class LCLC(SymbolDefine):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_MAC    # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"LCLC")
        self.process(asm,"LCLC",indefn._lclc,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


class LiteralStmt(DC):
    # Statement processing controls
    typ="MO"       # Statement type identifier
    lfld=None      # Valid label field content
    ofld=None      # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

        self.literal=self.optn.info    # Retrieve the original assembler.Literal
        self.trace=self.literal.trace       # Enable tracing if LTORG was traced
        self.literal._defined=self.lineno   # Remember where its is defined.

        if __debug__:
            if self.trace:
                print("%s literal: %s " \
                    % (assembler.eloc(self,"__init__",module=this_module),\
                        self.literal))

        # Match the state of the DC object following Pass0
        self.dcds_opnds.append(self.literal.constant)
        # Match the state of the DC object following Pass1 A
        self.values=self.literal.nominals

    def Pass0(self,asm,macro=None,debug=False,trace=False): pass
        # Pass 0 is completely handled by the Literal object, essentially matching
        # what DC.Pass0 does.

    def Pass1(self,asm,debug=False,trace=False):
        # Pass 1 A is handled by the Literal object.  From this point forward we
        # share the processing with the DC super class.

        if __debug__:
            tracing=self.trace

        # Make sure we have an active current section before doing anything more
        asm._check_cur_sec(debug=trace)
        first=self.buildArea(asm,self.values,debug=trace)

        # Supply the Literal object with the literals attributes.  Currently only
        # the L' as implied by the literal definition is supported for Storage-to-
        # Storage type instructions
        self.literal.attributes(self.content.loc,T=first.T,S=first.S,I=first.I)
        asm.cur_loc.increment(self.content,debug=tracing)

        if __debug__:
            if tracing:
                print("%s [%s] Literal object: %r" \
                    % (assembler.eloc(self,"Pass1",module=this_module),\
                        self.lineno,self.literal))
        self.literal.state=5
        if __debug__:
            if tracing:
                print("%s [%s] Created Literal from: %s" \
                    % (assembler.eloc(self,"Pass1",module=this_module),\
                        self.lineno,self.literal))

    # Pass 2 - uses DC.Pass2 to complete construction of the literal


# LTORG Assembler Directive - Oper Type: SPP
#
# Initiate a macro definition
#
# [label] LTORG  [comments]

class LTORG(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive
        self.pool=None           # The pool being created by this LTORG
        self.align=0             # Pool alignment

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        # Make sure we have an active current section before doing anything more
        asm._check_cur_sec(debug=pdebug)

        # Create the literal pool
        self.pool,self.align=self.literal_pool_create(asm,debug=pdebug)

    def Pass1(self,asm,debug=False,trace=False):
        pdebug=self.trace or debug
        # Perform alignment and define a label if present
        self.new_content(asm,alignment=self.align,length=0,debug=pdebug)

    def Pass2(self,asm,debug=False,trace=False): pass


# MACRO Assembler Directive - Oper Type: SPP
#
# Initiate a macro definition
#
# [label] MACRO  [DEBUG] [comments]

class MACRO(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld=None      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True         # This is a macro directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.ck_out_of_macro_defn(macro,"MACRO")
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        # Determine if optional 'DEBUG' operand present and set definition debug
        ddebug=False
        if self.opnd_fld is not None:
            opers=self.spp_remove_comments(self.opnd_fld.text)
            ddebug=opers.upper()=="DEBUG"

        macro.define(debug=ddebug)
        self.ignore=True

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# MEND Macro Directive - Oper Type: MD
#
# End a macro definition
#
# [seqsym] MEND  [comments]

class MEND(ASMStmt):
    # Statement processing controls
    typ="MD"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"MEND")
        self.pre_process(asm)

        # Finish the macro engine definition by adding the Mend op
        indefn._mend(self.lineno,seq=self.seqsym(asm.case))
        # Add the new macro to the definitions
        macro.addMacro(indefn,mend=True)

    # Pass1 - should never be called
    # Pass2 - should never be called


# MEXIT Macro Directive - Oper Type: MD
#
# Exit macro invocation
#
# [seqsym] MEXIT  [comments]

class MEXIT(ASMStmt):
    # Statement processing controls
    typ="MD"       # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=True       # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"MEXIT")
        self.pre_process(asm)

        indefn._mexit(self.lineno,seq=self.seqsym(asm.case))

    # Pass1 - should never be called
    # Pass2 - should never be called


# MHELP Assembler Directive - Oper Type: SPP

# Specify macro assistance options
#
# [seqsym] MHELP  <action>

class MHELP(TemplateStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression
    # Note: this needs updating to use parser "mopnd" to allow symbolic variables
    # in the expression.

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,]

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=1)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def ck_literals(self):
        self.ck_for_literals()

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        super().Pass0(asm,macro=macro,debug=debug,trace=trace)

        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        # Results are in the list self.PO_operands, asmbase.Operand subclass objects.
        self.evaluate_operands(asm,debug=edebug,trace=etrace)
        # Evaluated expression(s) in the self.bin_oprs list

        operand=self.bin_oprs[0].getValue()

        # Update the mhelp data in the macro manager (asmmacs.MacroLanguage object)
        asm.MM.mhelp(operand,debug=debug)

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# MNOTE Assembler Directive - Oper Type: SPP

# Generate an informational or error message
#
# [label] MNOTE sev,'message'

class MNOTE(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        pm=asm.PM
        scope=pm.parse_operands(self,"mnote",required=True)
        if __debug__:
            if pdebug:
                print("%s scope.severity: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        scope.severity))

        note=scope.message.convert()
        if scope.comment:
            info=True
            sev="*"
        else:
            if scope.severity is None:
                if len(scope.lextoks) == 0:
                    raise assembler.AssemblerError(line=self.lineno,\
                        msg="MNOTE operands unrecognized")
                desc="MNOTE %s" % self.lineno
                expr=pm.L2ArithExpr(desc,self,ltoks=scope.lextoks,debug=debug)
                operand=expr.evaluate(None,debug=debug,trace=False)
            else:
                operand=scope.severity
            if operand < 0 or operand> 255:
                operand=255
            info=False
            sev=operand

        msg="MNOTE %s,%s" % (sev,note)
        if __debug__:
            if pdebug:
                print("%s [%s] msg: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,msg))

        # This ensures the MNOTE statement appears in the listing
        raise assembler.AssemblerError(line=self.lineno,msg=msg,info=info)


    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# OPSYN Assembler Directive - Oper Type: SPP
#
# Define/Delete an operation name
#
# newop  OPSYN [oldop]

class OPSYN(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="LS"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        #trace=self.trace or debug
        if __debug__:
            if pdebug:
                print("%s [%s] label_fld: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,self.label_fld))
                print("%s [%s] opnd_fld: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,self.opnd_fld))

        operands=self.spp_operands()
        if __debug__:
            if pdebug:
                print("%s [%s] operands: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,operands))

        if len(operands)>1:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="OPSYN definition requires one operand, found %s" \
                    % len(operands))

        if len(operands)==0 and self.label_fld is None:
            # OPSYN without a label and without an operand just prints the table
            asm.OMF.opsyn_print(self)
            self.ignore=True
            return

        new_op=self.label_required()    # May raise an assembler error
        new_op=new_op.upper()           # Make the new operation upper case

        if len(operands)==1:
            old_op=operands[0].upper()
        else:
            old_op=None

        if not old_op:
            # Delete the operation synonym
            if __debug__:
                if pdebug:
                    print("%s [%s] OPSYN deleted operation: %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.lineno,new_op))
            asm.OMF.opsyn_setting(new_op,None,self.lineno,debug=pdebug)
        else:
            # Define or redefine an operation
            try:
                asm.OMF.opsyn_setting(new_op,old_op,self.lineno,debug=pdebug)
            except KeyError:
                raise assembler.AssemblerError(line=self.lineno,\
                    msg="instruction, directive, or macro does not exist: %s"\
                        % old_op)

            # Define or redefine an operation
            if __debug__:
                if pdebug:
                    print("%s [%s] OPSYN defined operation %s -> %s" \
                        % (assembler.eloc(self,"Pass0",module=this_module),\
                            self.lineno,new_op,old_op))

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# ORG Assembler Directive - Oper Type: TPL
#
# Adjust current location
#
# [label] ORG  expression

class ORG(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQS"     # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    template=[asmbase.SingleAny,]

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=1)

    def ck_literals(self):
        self.ck_for_literals()

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or trace or self.trace

        bin=assembler.Binary(0,0)  # Create a dummy Binary instance for the statement
        self.content=bin           # Establish the ORG statements binary content

        asm._check_cur_sec(debug=trace)  # Check that a CSECT is active
        asm.cur_sec.assign(bin)    # Assign to it its '*' value

        # Save value for listing and calculation of '*' values
        addr1=bin.loc
        self.location=self.p1_loc=addr1.clone()

        # Define the statement's label if present
        self.label_create(asm,length=1)   # Use binary content length

        # Now adjust to new location
        # Evaluate the starting address
        self.evaluate_operands(asm,debug=edebug,trace=etrace)
        operand=self.bin_oprs[0]
        new_loc=operand.getValue()

        # Validate we can use the result to adjust the location
        if not isinstance(new_loc,lnkbase.Address):
            assembler.AssemblerError(line=self.lineno,\
                msg="ORG result must be an address: %s" % new_loc)
        if not new_loc.isRelative():
             assembler.AssemblerError(line=self.lineno,\
                msg="ORG result must be a relative address: %s" % new_loc)

        cur_sec=asm.cur_sec
        if new_loc.section!=cur_sec:
            assembler.AssemblerError(line=self.lineno,\
                msg="ORG result must be in the active section ('%s'): %s" \
                    % (cur_sec.name,new_loc))

        cur_sec.org(new_loc)
        asm.cur_loc.establish(new_loc)
        self.laddr=[addr1,new_loc]

    def Pass2(self,asm,debug=False,trace=False): pass


# POP Assembler Directive - Oper Type: SPP
#
# POP - restore saved settings
#
#         POP    [USING][,PRINT][,NOPRINT]
#

class POP(StackingStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        ptrace = self.pre_process(asm) or debug
        self.parse_line(asm,debug=ptrace)

        #ptrace=self.trace or debug
        self.using,stack_print,no_print=self.stacking_operands(asm,debug=ptrace)
        if stack_print and len(asm.pstack)!=0:
            self.pon,self.pdata,self.pgen=asm.pstack.pop()
        if no_print:
            self.pon=False

    def Pass1(self,asm,debug=False,trace=False): pass
    #def Pass2(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False):
        if self.using:
            try:
                asm.bases.pop()
            except KeyError:
                raise assembler.AssemblerError(line=self.lineno,
                    msg="can not POP an empty USING stack")


# PRINT Assembler Directive - Oper Type: SPP
#
# PRINT - set listing option(s)
#
#         PRINT  option[,option]..

class PRINT(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        ptrace = self.pre_process(asm) or debug
        self.parse_line(asm,debug=ptrace)

        if __debug__:
            if ptrace:
                print("[%s] pline:  %s" % (self.lineno,self.logline.plines[0]))
                print("[%s] logline:%s" % (self.lineno,self.logline))

        # Labels are prohibited
        self.label_prohibited()    # AssemblerError raised if present

        # Extract the operand field from the statement
        operands=self.spp_operands(debug=ptrace)
        if len(operands)==0:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="PRINT directive requires at least one operand, none found")

        no_print=False
        if len(operands)>1 and operands[-1].upper() == 'NOPRINT':
            no_print=True
            operands=operands[:-1]
        for ndx,operand in enumerate(operands):
            original=operand
            operand=original.upper()
            if operand == "ON":
                asm.pon=True
            elif operand == "OFF":
                asm.pon=False
            elif operand == "GEN":
                asm.pgen=True
            elif operand == "NOGEN":
                asm.pgen=False
            elif operand == "DATA":
                asm.pdata=True
            elif operand == "NODATA":
                asm.pdata=False
            else:
                raise assembler.AssemblerError(line=self.lineno,
                    msg="PRINT directive operand %s unrecognized: %s" \
                        % (ndx+1,original))

        # NOPRINT controls whether the PRINT directive is printed or not.
        # The current setting of PRINT ON or OFF does not.
        if no_print:
            self.pon=False
        else:
            self.pon=True
        self.ignore=True          # No more processing for a PRINT directive
        if __debug__:
            if ptrace:
                print("%s [%s] asm.pon:%s asm.pgen:%s asm.pdata:%s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),self.lineno,\
                        asm.pon,asm.pgen,asm.pdata))

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# PSWS Assembler Directive - Oper Type: TPL
#
# Create a S/360-20 32-bit (short) PSW
#
# sys-> bits 7 (CM), key not used, a -> bit 6 (A), prog -> bits 2,3 (CC),
# addr -> bits 16-31, amode not used
#
# [label] PSWS   sys,key,a,prog,addr[,amode]

class PSWS(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    #
    #  PSWS Template
    #
    # sys-> bit 7 (CM), a -> bit 6 (A), prog -> bits 2,3 (CC), addr -> bits 16-31
    @staticmethod
    def structure(builder):
        fields=[insnbldr.Field(value=None,name="PSWS system field",size=1,start=7),
                insnbldr.Field(value=None,name="PSWS A field",size=1,start=6),
                insnbldr.Field(value=None,name="PSWS program field",size=2,start=2),
                insnbldr.Field(value=None,name="PSWS address field",size=16,start=16)]
        PSWS.struct=Structure("PSWS",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=1,length=4,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract PSWS operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        a=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()

        # Validate PSWS Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Build the PSWS content
        values=[sys,a,prog,pswaddr]
        bytes=PSWS.struct.build(self,values,trace=trace)
        # Update the statements binary content with the PSWS
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)


# PSW360 Assembler Directive - Oper Type: TPL
#
# Create a standard S/360 64-bit PSW
#
# sys -> bits 0-7, key -> bits 8-11, amwp -> bits 12-15, prog -> bits 34-39
# addr -> bits 40-63, amode not used
#
# [label] PSW360 sys,key,a,prog,addr[,amode]

class PSW360(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    #
    #  PSW360 Template
    #

    # sys -> bits 0-7, key -> bits 8-11, amwp -> bits 12-15, prog -> bits 34-39
    # addr -> bits 40-63
    @staticmethod
    def structure(builder):
        fields=[insnbldr.Field(value=None,name="PSW360 system field",size=8,start=0),
                insnbldr.Field(value=None,name="PSW360 key field",size=4,start=8),
                insnbldr.Field(value=None,name="PSW360 AMWP field",size=4,start=12),
                insnbldr.Field(value=None,name="PSW360 program field",size=6,start=34),
                insnbldr.Field(value=None,name="PSW360 address field",size=24,start=40)]
        PSW360.struct=Structure("PSW360",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
         # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract PSW360 operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        key=self.bin_oprs[1].getValue()
        amwp=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()

        # Validate PSW360 Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Build the PSW360 content
        values=[sys,key,amwp,prog,pswaddr]
        bytes=PSW360.struct.build(self,values,trace=trace)
        # Update the statements binary content with the PSW360
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)


# PSW67 Assembler Directive - Oper Type: TPL
#
# Create a standard S/360-67 64-bit PSW
#
# sys -> bits 0-7, key -> bits 8-11, amwp -> bits 12-15, prog -> bits 34-39
# addr -> bits 40-63
#
# [label] PSW67  sys,key,a,prog,addr[,amode]

class PSW67(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    amodes={0:0,1:1,24:0,32:1}   # S/360 Model 67 bimodal addressing

    #
    #  PSW67 Template
    #

    # sys -> bits 5-7, key -> bits 8-11, amwp -> bits 12-15, prog -> bits 16-23
    # addr -> bits 32-63, amode -> bit 4
    @staticmethod
    def structure(builder):
        fields=[insnbldr.Field(value=None,name="PSW67 system field",size=3,start=5),
                insnbldr.Field(value=None,name="PSW67 key field",size=4,start=8),
                insnbldr.Field(value=None,name="PSW67 AMWP field",size=4,start=12),
                insnbldr.Field(value=None,name="PSW67 program field",size=8,start=16),
                insnbldr.Field(value=None,name="PSW67 address field",size=32,start=32),
                insnbldr.Field(value=None,name="PSW67 amode field",size=1,start=4)]
        PSW67.struct=Structure("PSW67",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract PSW67 operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        key=self.bin_oprs[1].getValue()
        amwp=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()
        if len(self.bin_oprs)==6:
            amode=self.bin_oprs[5].getValue()
        else:
            amode=0

        # Validate PSW67 Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Validate PSW67 Address Mode - Operand 6
        try:
            pswamode=PSW67.amodes[amode]
        except KeyError:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operand 6 is an invalid 360-67 bimodal address mode: %s" \
                    % (self.instu,amode))

        # Build the PSW67 content
        values=[sys,key,amwp,prog,pswaddr,pswamode]
        bytes=PSW67.struct.build(self,values,trace=trace)
        # Update the statements binary content with the PSW67
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)


# PSWBC Assembler Directive - Oper Type: TPL
#
# Create an S/370 Basic Control mode 64-bit PSW
#
# sys -> bits 0-7, key -> bits 8-11, mwp -> bits 13-15, prog -> bits 34-39
# addr -> bits 40-63, amode not used
#
# [label] PSWBC  sys,key,mwp,prog,addr[,amode]

class PSWBC(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    #
    #  PSWBC Template
    #

    # sys -> bits 0-7, key -> bits 8-11, mwp -> bits 13-15, prog -> bits 34-39
    # addr -> bits 40-63
    @classmethod
    def structure(cls,builder):
        fields=[insnbldr.Field(value=None,name="PSWBC system field",size=8,start=0),
                insnbldr.Field(value=None,name="PSWBC key field",size=4,start=8),
                insnbldr.Field(value=None,name="PSWBC MWP field",size=3,start=13),
                insnbldr.Field(value=None,name="PSWBC program field",size=6,start=34),
                insnbldr.Field(value=None,name="PSWBC address field",size=24,start=40)]
        cls.struct=Structure("PSWBC",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract PSWBC operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        key=self.bin_oprs[1].getValue()
        mwp=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()

        # Validate PSWBC Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Build the PSWBC content
        values=[sys,key,mwp,prog,pswaddr]
        bytes=PSWBC.struct.build(self,values,trace=trace)
        # Update the statements binary content with the PSWBC
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)


# PSWEC Assembler Directive - Oper Type: TPL
#
# PSWEC - Create an S/370 Extended Control mode 64-bit PSW
#
# sys -> bits 0-7, key -> bits 8-12, mwp -> bits 13-15, prog -> bits 16-24
# addr -> bits 40-63, amode not used
#
# [label] PSWEC  sys,key,mwp,prog,addr[,amode]

class PSWEC(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    #
    #  PSWEC Template
    #

    # sys -> bits 0-7, key -> bits 8-12, mwp -> bits 13-15, prog -> bits 16-23
    # addr -> bits 40-63
    @classmethod
    def structure(cls,builder):
        fields=[insnbldr.Field(value=None,name="PSWEC system field",size=8,start=0),
                insnbldr.Field(value=None,name="PSWEC key field",size=4,start=8),
                insnbldr.Field(value=1,   name="PSWEC mode field",size=1,start=12),
                insnbldr.Field(value=None,name="PSWEC MWP field",size=3,start=13),
                insnbldr.Field(value=None,name="PSWEC program field",size=8,start=16),
                insnbldr.Field(value=None,name="PSWEC address field",size=24,start=40)]
        cls.struct=Structure("PSWEC",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract PSWEC operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        key=self.bin_oprs[1].getValue()
        mwp=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()

        sys =  sys  & 0b01000111   # Make sure PSW bits 0 and 2-4 are zero
        prog = prog & 0b10111111   # Make sure PSW bit 17 is zero

        # Validate PSWEC Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Build the PSWEC content
        values=[sys,key,None,mwp,prog,pswaddr]
        bytes=PSWEC.struct.build(self,values,trace=trace)
        # Update the statements binary content with the PSWEC
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)


# Bimodal Addressing PSW's - Oper Type: TPL
#
# PSW380  - Create a Hercles S/380 mode 64-bit PSW
# PSWXA   - Create an S/370-XA 64-bit PSW
# PSWE370 - Create an ESA/370 64-bit PSW
# PSWE390 - Create an ESA/390 64-bit PSW
#
# sys -> bits 0-7, key -> bits 8-12, mwp -> bits 13-15, prog -> bits 16-23
# addr -> bits 33-63, amode -> 32
#
# [label] PSW380   sys,key,mwp,prog,addr[,amode]
# [label] PSWXA    sys,key,mwp,prog,addr[,amode]
# [label] PSWE370  sys,key,mwp,prog,addr[,amode]
# [label] PSWE390  sys,key,mwp,prog,addr[,amode]

class PSWBi(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    amodes={0:0,1:1,24:0,31:1}
    biprog={"PSW380": 0b10111111,
            "PSWXA":  0b10111111,
            "PSWE370":0b11111111,
            "PSWE390":0b11111111}

    #
    #  PSW380, PSWXA, PSWE370 and PSWE390 Templates
    #

    @classmethod
    def structure(cls,builder):
        # Copy PSWBi class attributes to the subclass
        cls.typ=   PSWBi.typ
        cls.lfld=  PSWBi.lfld
        cls.ofld=  PSWBi.ofld
        cls.alt=   PSWBi.alt
        cls.parser=PSWBi.parser
        cls.sep=   PSWBi.sep
        cls.spaces=PSWBi.spaces
        cls.comma= PSWBi.comma
        cls.attrs= PSWBi.attrs
        name=cls.__name__
        fields=[insnbldr.Field(value=None,name="%s system field" % name,\
                               size=8,start=0),
                insnbldr.Field(value=None,name="%s key field" % name,\
                               size=4,start=8),
                insnbldr.Field(value=1,name="%s mode field" % name,\
                               size=1,start=12),
                insnbldr.Field(value=None,name="%s MWP field" % name,\
                               size=3,start=13),
                insnbldr.Field(value=None,name="%s program field" % name,\
                               size=8,start=16),
                insnbldr.Field(value=None,name="%s amode field" % name,\
                               size=1,start=32),
                insnbldr.Field(value=None,name="%s address field" % name,\
                               size=31,start=33)]
        cls.struct=Structure(name,builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    # Returns the value to be used in a bimodal address mode PSW
    # raises an AssemblerError if an invalid value is supplied.
    def struct_bimode(self,opn,amode):
        try:
            return PSWBi.amodes[amode]
        except KeyError:
            raise asembler.AssemblerError(line=self.lineno,\
                msg="%s operand %s is an invalid bimodal address mode: %s" \
                    % (self.instu,opn,amode))

    # This method validates that amode is consistent for 24-bit vs 31-bit
    def struct_bimode_check(self,opn,am,addr):
        if not am and (addr > 0xFFFFFF):
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operand %s must be a 24-bit address: %s" \
                    % (self.instu,opn,hex(addr)))

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=8,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        # Instruction name is the actual instruction, for example, PSWE390,
        # not the coded instruction, for example, PSW.
        inst=self.instu

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        key=self.bin_oprs[1].getValue()
        mwp=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()

        if len(self.operands)==6:
            amode=self.bin_oprs[5].getValue()
        else:
            amode=0

        try:
            pmask=PSWBi.biprog[inst]
        except KeyError:
            raise ValueError("%s unrecognized instruction for bimodal prog field "
                "mask: %s" % (assembler.eloc(self,"Pass2"),inst))

        prog = prog & pmask        # Make sure any reserved bits are zero
        sys =  sys  & 0b01000111   # Make sure PSW bits 0 and 2-4 are zero

        # Validate Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Validate Address Mode - Operand 6
        am=self.struct_bimode(6,amode)

        # Make sure we have a 24-bit address if the address mode is 24
        self.struct_bimode_check(6,am,pswaddr)

        # Build the content
        values=[sys,key,None,mwp,prog,am,pswaddr]
        bytes=self.__class__.struct.build(self,values,trace=trace)
        # Update the statements binary content with the PSW
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)

#
# The following classes are required for proper error reporting by the structure
# build process when detecting operand errors.  The underlying process requires
# the insnbldr.Field object name contains the statement name.  Without these
# classes errors are reported as coming from PSWBi, a name meaningless to the
# end user.
#


class PSW380(PSWBi):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)


class PSWXA(PSWBi):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)


class PSWE370(PSWBi):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)


class PSWE390(PSWBi):
    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)


# PSWZ Assembler Directive - Oper Type: TPL
#
# Create a z/Architecture (RTM) mode 128-bit PSW
#
# sys -> bits 0-7, key -> bits 8-12, mwp -> bits 13-15, prog -> bits 16-24
# addr -> 64-127, amode -> bits 31,32
#
# [label] PSWZ   sys,key,mwp,prog,addr[,amode]

class PSWZ(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="LQ"      # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.SingleAny,asmbase.Single]

    amodes={0:0,1:1,3:3,24:0,31:1,64:3}

    #
    #  PSWZ Template
    #

    # sys -> bits 0-7, key -> bits 8-12, mwp -> bits 13-15, prog -> bits 16-24
    # addr -> 64-127, amode -> bits 31,32
    @classmethod
    def structure(cls,builder):
        fields=[insnbldr.Field(value=None,name="PSWZ system field",size=8,start=0),
                insnbldr.Field(value=None,name="PSWZ key field",size=4,start=8),
                insnbldr.Field(value=None,name="PSWZ MWP field",size=3,start=13),
                insnbldr.Field(value=None,name="PSWZ program field",size=8,start=16),
                insnbldr.Field(value=None,name="PSWZ amode field",size=2,start=31),
                insnbldr.Field(value=None,name="PSWZ address field",size=64,start=64)]
        cls.struct=Structure("PSWZ",builder,fields)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def ck_literals(self):
        self.ck_for_literals()

    # Returns the value to be used in a trimodal address mode PSW
    # raises an AssemblerError if an invalid value is supplied.
    def struct_trimode(self,opn,amode):
        try:
            return PSWZ.amodes[amode]
        except KeyError:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operand %s is an invalid trimodal address mode: %s" \
                    % (self.instu,opn,amode))

     # This method validates that amode is consistent for 24-bit vs 31-bit
    def struct_trimode_check(self,opn,am,addr):
        if am == 0 and (addr > 0xFFFFFF):
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operand %s must be a 24-bit address: %s" \
                    % (self.instu,opn,hex(addr)))
        if am == 1 and (addr > 0x7FFFFFFF):
            raise assembler.AssemblerError(line=self.lineno,\
                msg="%s operand %s must be a 31-bit address: %s" \
                    % (self.instu,opn,hex(addr)))

     #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,debug=False,trace=False):
        # Create the binary content and assign a label if present in the statement
        self.new_content(asm,alignment=8,length=16,T="3")
        asm.cur_loc.increment(self.content)

    def Pass2(self,asm,debug=False,trace=False):
        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        self.evaluate_operands(asm,debug=edebug,trace=etrace)

        # Extract operand values after expression evalution
        sys=self.bin_oprs[0].getValue()
        key=self.bin_oprs[1].getValue()
        mwp=self.bin_oprs[2].getValue()
        prog=self.bin_oprs[3].getValue()
        addr=self.bin_oprs[4].getValue()

        if len(self.operands)==6:
            amode=self.bin_oprs[5].getValue()
        else:
            amode=0

        # Validate Address - Operand 5
        pswaddr=self.struct_address(5,addr)

        # Validate Address Mode - Operand 6
        am=self.struct_trimode(6,amode)

        # Make sure we have a 24-bit address if the address mode is 24 or
        # we have a 31-bit address if the address mode is 31.
        self.struct_trimode_check(6,am,pswaddr)

        # Build the content
        values=[sys,key,mwp,prog,am,pswaddr]
        bytes=PSWZ.struct.build(self,values,trace=trace)
        # Update the statement's binary content with the PSW
        self.content.update(bytes,at=0,full=True,finalize=True,trace=ptrace)

# PUSH Assembler Directive - Oper Type: SPP
#
# Restores settings previously saved using a POP directive.
#
#         PUSH   [USING][,PRINT][,NOPRINT]

class PUSH(StackingStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        ptrace = self.pre_process(asm) or debug
        self.parse_line(asm,debug=ptrace)

        self.using,stack_print,no_print=self.stacking_operands(asm,debug=ptrace)
        if stack_print:
            options=(self.pon,self.pdata,self.pgen)
            asm.pstack.append(options)
        if no_print:
            self.pon=False

    def Pass1(self,asm,debug=False,trace=False): pass
    #def Pass2(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False):
        if self.using:
            asm.bases.push()


# REGION Assembler Directive - Oper Type: SPP
#
# REGION - continue an existing region.  Use START to initiate a new region
#
# label REGION  # no operands

class REGION(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

        # Pass 0
        self.region=None         # Name of region being continued
        self.for_pass2=None      # Information passed to Pass2 from Pass1

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm)
        self.parse_line(asm,debug=pdebug)

        self.region=self.label_required()

    def Pass1(self,asm,debug=False,trace=False):
        # Continue an existing region
        rdebug=trace or self.trace

        region_name=self.region  # Fetch the region name from Pass 0

        # the REGION must already be defined, we are continueing one already started
        if __debug__:
            if rdebug:
                print("%s [%s] referencing region in symbol table: '%s'" \
                    % (assembler.eloc(self,"Pass1",module=this_module),\
                        self.lineno,region_name))

        region=asm._region_ref(self,region_name)
        # If the region is not defined, an AssemblerError will have bailed us out

        # Make the found region the current one.
        asm._region_activate(region,debug=rdebug)
        self.for_pass2=region

    def Pass2(self,asm,debug=False,trace=False):
        # Prepare listing information
        region=self.for_pass2
        addr1=region.loc
        addr2=addr1+(max(len(region)-1,0))
        self.laddr=[addr1,addr2]


# RMODE Assembler Directive - Oper Type: SPP
#
# Set a control-section's residency mode
#
# [CSECT] RMODE 24|31|64|ANY

class RMODE(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        self.ignore=True         # Treat as a comment

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# SETA Macro Directive - Oper Type: MS
#
# Set a local or global arithemetic symbolic variable or array element
#
# &sym(n) SETA  arithmetic expression

class SETA(SETx):
    # Statement processing controls
    typ="MS"       # Statement type identifier
    lfld="S"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    #attrs="KNT"    # Attributes supported in expression
    attrs=A_MAC    # Attributes supported in expression (all allowed)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"SETA")
        self.process(asm,"seta",indefn._seta,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# SETB Macro Directive - Oper Type: MS
#
# Set a local or global binary symbolic variable
#
# &sym    SETB  binary-expression
#
# Set one or more local or global subscripted binary symbolic array elements
#
# &sym(n) SETB  binary-expression,...

class SETB(SETx):
    # Statement processing controls
    typ="MS"       # Statement type identifier
    lfld="S"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=True    # Whether operand field may have spaces outside of quoted strings
    comma=True     # Whether only a comma forces an end of an operand
    #attrs="KNT"    # Attributes supported in expression
    attrs=A_MAC    # Attributes supported in expression (all allowed)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"SETB")
        self.process(asm,"setb",indefn._setb,debug=debug)

    # Pass1 - should never be called
    # Pass2 - should never be called


# SETC Macro Directive - Oper Type: MS
#
# Set a local or global character symbolic variable or array element
#
# &sym(n) SETC  character expression

class SETC(SETx):
    # Statement processing controls
    typ="MS"      # Statement type identifier
    lfld="S"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    #attrs="KNT"    # Attributes supported in expression
    attrs=A_MAC    # Attributes supported in expression (all allowed)

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.macdir=True       # This is a macro directive
        self.syslist=False     # Whether &SYSLIST required in macro

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        indefn=self.ck_in_macro_defn(macro,2,"SETC")
        self.process(asm,"setc",macro.indefn._setc,debug=self.trace)

    # Pass1 - should never be called
    # Pass2 - should never be called


# SPACE Assembler Directive - Oper Type: SPP
#
# Insert one or more empty lines into listing
#
#         SPACE [n]

class SPACE(TemplateStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    struct=None    # Built by structure staticmethod
    template=[asmbase.Single,]

    def __init__(self,lineno,logline=None):
        #super().__init__(lineno,logline=logline,minimum=1)
        super().__init__(lineno,logline=logline,minimum=None)
        self.asmdir=True         # This is an assembler directive
        self.prdir=True          # This ia also a print directive

    def ck_literals(self):
        self.ck_for_literals()

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        super().Pass0(asm,macro=macro,debug=debug,trace=trace)

        ptrace=trace or self.trace
        edebug=asm.dm.isdebug("exp")
        etrace=asm.dm.isdebug("tracexp") or ptrace

        if len(self.P0_operands)==0:
            self.plist=1   # When operands are omitted, defaults to 1 line
        else:
            # Results are in the list self.PO_operands, asmbase.Operand subclass
            # objects.
            self.evaluate_operands(asm,debug=edebug,trace=etrace)
            # Evaluated expression(s) in the self.bin_oprs list

            # Communicate number of space lines to listing manager
            self.plist=self.bin_oprs[0].getValue()

        self.prdir=True           # This statement requires processing during listing
        self.ignore=True          # No more processing needed by assembler passes

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# START Assembler Directive - Oper Type: SPP
#
# Start a new control section and optionally a new region
#
# [label] START [address][,[region]]

class START(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="LSQ"     # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

        # Pass 0
        self.gscope=None         # Pass 0 scope object returned by parser
        self.csect=None          # CSECT being initiated
        self.region=None         # REGION being initiated

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        pm=asm.PM
        # Either of these two methods may raise an AssemblerError
        scope=self.gscope=pm.parse_scope(self,"start")
        scope.Pass0(self,pm,debug=pdebug)    # Should this move here????

        #self.gscope=scope   # Remember the Pass0 processing
        self.csect=self.label_optional()
        if __debug__:
            if pdebug:
                print("%s [%s] self.csect: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,self.csect))
                print("%s [%s] new_region: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,scope.reg_name))
                print("%s [%s] scope.new_region: %s" \
                    % (assembler.eloc(self,"Pass0",module=this_module),\
                        self.lineno,scope.new_region))

        if scope.new_region:
            if scope.reg_name == self.csect:
                if __debug__:
                    if pdebug:
                        print("%s REGION and CSECT names the same"\
                            % assembler.eloc(self,"Pass0",module=this_module))
                ae=assembler.AssemblerError(line=self.lineno,warning=True,\
                    msg="WARNING: REGION name ignored - must not be the same as "\
                        "CSECT name: %s" % scope.reg_name)
                asm._ae_excp(ae,self)
                scope.new_region=False  # Disable region handling in Pass2()
            else:
                self.region=scope.reg_name

    def Pass1(self,asm,debug=False,trace=False):
        utrace=trace or self.trace
        csect_name=self.csect

        # If the CSECT can not be created an AssemblerError is raised
        if csect_name:
            asm._csect_safe(self,csect_name)
        else:
            asm._csect_unname_safe(self)

        scope=self.gscope    # Scope is a asmfsmcs.START_Scope object
        region=scope.region
        start=0
        if scope.new_region:
            # Creating a new region too...
            # If the region can not be created an AssemblerError is generated
            if region:
                asm._region_safe(self,region)
            else:
                asm._region_unname_safe(self)

            # Calculate the region's starting address if provided, use 0 otherwise

            if scope.expr:
                start=asm.PM.evaluate_expr(asm,self,scope.expr,\
                    debug=debug,trace=trace)

            # Create the new region before creating the control section
            if region:
                region=asm._region_new(self.lineno,scope.region,start,debug=utrace)
                # Named region is now in the symbol table and added to the image
            else:
                region=asm._region_unname(start,debug=debug)
                # The unnamed region is now added to the image.
            # Make the new region the current active region
            asm._region_activate(region,debug=False)

        # Create the new control section
        if csect_name:
            csect=asm._csect_new(self.lineno,csect_name,debug=utrace)
            # Named control section is now in the symbol table and added to the
            # current active region.
        else:
            csect=asm._csect_unname(debug=utrace)
            # The unnamed control section is now part of the current active region.

        # If there was no active region, a new unnamed region was automatically
        # created even if no operands defining a region were supplied.

        # Make the new control section the active one.
        asm._csect_activate(csect,debug=utrace)

        # If this is the first START directive
        if asm.load is None:
            asm.load=start
            asm.entry=start  # An END directive can supply a different entry point

        self.laddr=csect

    def Pass2(self,asm,debug=False,trace=False):
        csect=self.laddr
        addr1=csect.loc
        addr2=addr1+max(len(csect)-1,0)
        self.laddr=[addr1,addr2]
        # Reset the location counter
        asm.cur_loc.establish(csect.loc)


# TITLE Assembler Directive - Oper Type: SPP

# Set a new listing title
#
#         TITLE  ['new listing title']

class TITLE(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="LMSQ"    # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="mopnd" # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is ans assembler directive
        self.prdir=True          # It is also a print directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm)

        self.ignore=True         # No more processing needed by assembler passes
        if len(self.operands)==0:
            self.plist=""
        elif len(self.operands)==1:
            result=asm.PM.parse_operand(self,self.operands[0],"TITLE",debug=pdebug)
            self.plist=result.convert(amp=True)    # New title in listing
        else:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="TITLE directive supports only one operand, found: %s" \
                    % len(self.operands))

        self.prdir=True        # This statement requires processing during listing

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


# USING Assembler Directive - Oper Type: TPL

# Set a new listing title
#
#         USING  base,reg[,reg]...

class USING(TemplateStmt):
    # Statement processing controls
    typ="TPL"      # Statement type identifier
    lfld="Q"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser="opnd"  # Operand parser used by statement
    sep=True       # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=A_OC     # Attributes supported in expression

    # Template structure definitions
    template=[asmbase.SingleAddress,\
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single,\
              asmbase.Single,asmbase.Single,asmbase.Single,asmbase.Single]

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline,minimum=2)
        self.asmdir=True         # This is an assembler directive

    def ck_literals(self):
        self.ck_for_literals(allowed=[0,])

    #   Pass0 uses TemplateStmt.Pass0() method

    def Pass1(self,asm,macro=None,debug=False,trace=False):
        # This is required in the case a USING occurs without a preceding CSECT or
        # START directive.
        asm._check_cur_sec(debug=trace)
        bin=assembler.Binary(0,0) # Create a dummy Binary instance for the statement
        self.content=bin   # Establish the USING statement's "binary" content
        asm.cur_sec.assign(bin)   # Assign to it its '*' value

        # Save value for listing and calculation of '*' values
        self.location=self.p1_loc=bin.loc.clone()

        # Define the statement's label if present
        self.label_create(asm,1)  # Use minimum length of 1

    def Pass2(self,asm,debug=False,trace=False):
        utrace=trace or self.trace
        etrace=asm.dm.isdebug("tracexp") or utrace
        edebug=asm.dm.isdebug("exp")

        if __debug__:
            if utrace:
                cls_str=assembler.eloc(self,"Pass2",module=this_module)
                lineno=self.lineno
                print("%s [%s] content location: %s" \
                    % (cls_str,lineno,self.content.loc))
                print("%s [%s] %s operands: %s"\
                    % (cls_str,lineno,self.inst,self.operands))
                print("%s [%s] Location Counter: %s" \
                    % (cls_str,lineno,asm.cur_loc.retrieve()))

        self.evaluate_operands(asm,debug=edebug,trace=etrace)
        # Results of evaluation update the bin_opr list elements
        addr=self.bin_oprs[0].getValue()

        if __debug__:
            if utrace:
                print("%s [%s] using base address %s" % (cls_str,lineno,addr))

        if addr.isRelative() and not addr.isDummy():
            addr.makeAbs()  # Added
            if __debug__:
                if utrace:
                    print("%s [%s] made base address absolute: %s" \
                        % (cls_str,lineno,addr))

        self.laddr=[addr,None]
        regs=[]
        for x in range(1,len(self.operands)):
            if __debug__:
                if utrace:
                    print("%s [%s] register operand number: %s" % (cls_str,lineno,x))
            reg=self.bin_oprs[x].getValue()
            regs.append(reg)
        if __debug__:
            if utrace:
                print("%s [%s] bases being assigned to registers: %s" \
                    % (cls_str,lineno,regs))

        for r in regs:
            asm.bases.using(r,addr,trace=utrace)
            addr=addr+4096

        if __debug__:
            if utrace:
                print("%s [%s]\n%s" \
                    % (cls_str,self.lineno,\
                        asm.bases.print(indent="    ",string=True)))


# XMODE Assembler Directive: Oper Type: SPP
#
# Set execution mode option
#
#         XMODE  mode,setting

class XMODE(ASMStmt):
    # Statement processing controls
    typ="SPP"      # Statement type identifier
    lfld="L"       # Valid label field content
    ofld="L"       # Valid operation field content
    alt=False      # Whether the alternate statement format is allowed
    parser=None    # Operand parser used by statement
    sep=False      # Whether operands are to be separated from the logline
    spaces=False   # Whether operand field may have spaces outside of quoted strings
    comma=False    # Whether only a comma forces an end of an operand
    attrs=None     # Attributes supported in expression

    def __init__(self,lineno,logline=None):
        super().__init__(lineno,logline=logline)
        self.asmdir=True         # This is an assembler directive

    def Pass0(self,asm,macro=None,debug=False,trace=False):
        pdebug = self.pre_process(asm) or debug
        self.parse_line(asm,debug=pdebug)

        operands=self.spp_operands(debug=pdebug)
        if len(operands)!=2:
            raise assembler.AssemblerError(line=self.lineno,\
                msg="XMODE directive requires two operands, found: %s" \
                    % len(operands))

        mode=operands[0].upper()
        setting=operands[1].upper()

        # Set the XMODE.  AssemblerError may be raised if either mode or setting is
        # invalid.
        asm.OMF.xmode_setting(self,mode,setting)
        self.ignore=True          # Processing completed

    def Pass1(self,asm,debug=False,trace=False): pass
    def Pass2(self,asm,debug=False,trace=False): pass


if __name__ == "__main__":
    raise NotImplementedError("%s - intended for import use only" % this_module)
